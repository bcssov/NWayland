using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice
{
    /// <summary>
    /// An outputdevice describes a display device available to the compositor.outputdevice is similar to wl_output, but focuses on outputconfiguration management.<br/><br/>
    /// A client can query all global outputdevice objects to enlist allavailable display devices, even those that may currently not berepresented by the compositor as a wl_output.<br/><br/>
    /// The client sends configuration changes to the server through theoutputconfiguration interface, and the server applies the configurationchanges to the hardware and signals changes to the outputdevicesaccordingly.<br/><br/>
    /// This object is published as global during start up for every availabledisplay devices, or when one later becomes available, for example bybeing hotplugged via a physical connector.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinOutputdevice : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinOutputdevice()
        {
            NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface = new WlInterface("org_kde_kwin_outputdevice", 4, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("geometry", "iiiiissi", new WlInterface*[] { null, null, null, null, null, null, null, null }),
                new WlMessage("mode", "uiiii", new WlInterface*[] { null, null, null, null, null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("scale", "i", new WlInterface*[] { null }),
                new WlMessage("edid", "s", new WlInterface*[] { null }),
                new WlMessage("enabled", "i", new WlInterface*[] { null }),
                new WlMessage("uuid", "s", new WlInterface*[] { null }),
                new WlMessage("scalef", "2f", new WlInterface*[] { null }),
                new WlMessage("colorcurves", "2aaa", new WlInterface*[] { null, null, null }),
                new WlMessage("serial_number", "2s", new WlInterface*[] { null }),
                new WlMessage("eisa_id", "2s", new WlInterface*[] { null }),
                new WlMessage("capabilities", "3u", new WlInterface*[] { null }),
                new WlMessage("overscan", "3u", new WlInterface*[] { null }),
                new WlMessage("vrr_policy", "4u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// The geometry event describes geometric properties of the output.The event is sent when binding to the output object and wheneverany of the properties change.<br/><br/>
            /// </summary>
            void OnGeometry(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, int @x, int @y, int @physicalWidth, int @physicalHeight, int @subpixel, string @make, string @model, int @transform);

            /// <summary>
            /// The mode event describes an available mode for the output.<br/><br/>
            /// When the client binds to the outputdevice object, the server sends thisevent once for every available mode the outputdevice can be operated by.<br/><br/>
            /// There will always be at least one event sent out on initial binding,which represents the current mode.<br/><br/>
            /// Later on if an output changes its mode the event is sent again, wherebythis event represents the mode that has now become current. In otherwords, the current mode is always represented by the latest event sentwith the current flag set.<br/><br/>
            /// The size of a mode is given in physical hardware units of the output device.This is not necessarily the same as the output size in the global compositorspace. For instance, the output may be scaled, as described inorg_kde_kwin_outputdevice.scale, or transformed, as described inorg_kde_kwin_outputdevice.transform.<br/><br/>
            /// The id can be used to refer to a mode when calling set_mode on anorg_kde_kwin_outputconfiguration object.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, uint @flags, int @width, int @height, int @refresh, int @modeId);

            /// <summary>
            /// This event is sent after all other properties have beensent on binding to the output object as well as after anyother output property change have been applied later on.This allows to see changes to the output properties as atomic,even if multiple events successively announce them.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender);

            /// <summary>
            /// This event contains scaling geometry informationthat is not in the geometry event. It may be sent afterbinding the output object or if the output scale changeslater. If it is not sent, the client should assume ascale of 1.<br/><br/>
            /// A scale larger than 1 means that the compositor willautomatically scale surface buffers by this amountwhen rendering. This is used for high resolutiondisplays where applications rendering at the nativeresolution would be too small to be legible.<br/><br/>
            /// It is intended that scaling aware clients track thecurrent output of a surface, and if it is on a scaledoutput it should use wl_surface.set_buffer_scale withthe scale of the output. That way the compositor canavoid scaling the surface, and the client can supplya higher detail image.<br/><br/>
            /// </summary>
            void OnScale(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, int @factor);

            /// <summary>
            /// The edid event encapsulates the EDID data for the outputdevice.<br/><br/>
            /// The event is sent when binding to the output object. The EDIDdata may be empty, in which case this event is sent anyway.If the EDID information is empty, you can fall back to the nameet al. properties of the outputdevice.<br/><br/>
            /// </summary>
            void OnEdid(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, string @raw);

            /// <summary>
            /// The enabled event notifies whether this output is currentlyenabled and used for displaying content by the server.The event is sent when binding to the output object andwhenever later on an output changes its state by becomingenabled or disabled.<br/><br/>
            /// </summary>
            void OnEnabled(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, int @enabled);

            /// <summary>
            /// The uuid can be used to identify the output. It's controlled bythe server entirely. The server should make sure the uuid ispersistent across restarts. An empty uuid is considered invalid.<br/><br/>
            /// </summary>
            void OnUuid(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, string @uuid);

            /// <summary>
            /// This event contains scaling geometry informationthat is not in the geometry event. It may be sent afterbinding the output object or if the output scale changeslater. If it is not sent, the client should assume ascale of 1.<br/><br/>
            /// A scale larger than 1 means that the compositor willautomatically scale surface buffers by this amountwhen rendering. This is used for high resolutiondisplays where applications rendering at the nativeresolution would be too small to be legible.<br/><br/>
            /// It is intended that scaling aware clients track thecurrent output of a surface, and if it is on a scaledoutput it should use wl_surface.set_buffer_scale withthe scale of the output. That way the compositor canavoid scaling the surface, and the client can supplya higher detail image.<br/><br/>
            /// wl_output will keep the output scale as an integer. In every situation exceptconfiguring the window manager you want to use that.<br/><br/>
            /// </summary>
            void OnScalef(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, WlFixed @factor);

            /// <summary>
            /// Describes the color intensity profile of the output.Commonly used for gamma/color correction.<br/><br/>
            /// The array contains all color ramp values of the output.For example on 8bit screens there are 256 of them.<br/><br/>
            /// The array elements are unsigned 16bit integers.<br/><br/>
            /// </summary>
            void OnColorcurves(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, ReadOnlySpan<byte> @red, ReadOnlySpan<byte> @green, ReadOnlySpan<byte> @blue);

            /// <summary>
            /// Serial ID of the monitor, sent on startup before the first done event.<br/><br/>
            /// </summary>
            void OnSerialNumber(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, string @serialNumber);

            /// <summary>
            /// EISA ID of the monitor, sent on startup before the first done event.<br/><br/>
            /// </summary>
            void OnEisaId(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, string @eisaId);

            /// <summary>
            /// What capabilities this device has, sent on startup before the firstdone event.<br/><br/>
            /// </summary>
            void OnCapabilities(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, CapabilityEnum @flags);

            /// <summary>
            /// Overscan value of the monitor in percent, sent on startup before thefirst done event.<br/><br/>
            /// </summary>
            void OnOverscan(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, uint @overscan);

            /// <summary>
            /// What policy the compositor will employ regarding its use of variablerefresh rate.<br/><br/>
            /// </summary>
            void OnVrrPolicy(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice eventSender, VrrPolicyEnum @vrrPolicy);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGeometry(this, arguments[0].Int32, arguments[1].Int32, arguments[2].Int32, arguments[3].Int32, arguments[4].Int32, Marshal.PtrToStringAnsi(arguments[5].IntPtr), Marshal.PtrToStringAnsi(arguments[6].IntPtr), arguments[7].Int32);
                    break;
                case 1:
                    Events?.OnMode(this, arguments[0].UInt32, arguments[1].Int32, arguments[2].Int32, arguments[3].Int32, arguments[4].Int32);
                    break;
                case 2:
                    Events?.OnDone(this);
                    break;
                case 3:
                    Events?.OnScale(this, arguments[0].Int32);
                    break;
                case 4:
                    Events?.OnEdid(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 5:
                    Events?.OnEnabled(this, arguments[0].Int32);
                    break;
                case 6:
                    Events?.OnUuid(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 7:
                    Events?.OnScalef(this, arguments[0].WlFixed);
                    break;
                case 8:
                    Events?.OnColorcurves(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr), WlArray.SpanFromWlArrayPtr<byte>(arguments[1].IntPtr), WlArray.SpanFromWlArrayPtr<byte>(arguments[2].IntPtr));
                    break;
                case 9:
                    Events?.OnSerialNumber(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 10:
                    Events?.OnEisaId(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 11:
                    Events?.OnCapabilities(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
                case 12:
                    Events?.OnOverscan(this, arguments[0].UInt32);
                    break;
                case 13:
                    Events?.OnVrrPolicy(this, (VrrPolicyEnum)arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// This enumeration describes how the physical pixels on an output arelaid out.<br/><br/>
        /// </summary>
        public enum SubpixelEnum
        {
            Unknown = 0,
            None = 1,
            HorizontalRgb = 2,
            HorizontalBgr = 3,
            VerticalRgb = 4,
            VerticalBgr = 5
        }

        /// <summary>
        /// This describes the transform, that a compositor will apply to asurface to compensate for the rotation or mirroring of anoutput device.<br/><br/>
        /// The flipped values correspond to an initial flip around avertical axis followed by rotation.<br/><br/>
        /// The purpose is mainly to allow clients to render accordingly andtell the compositor, so that for fullscreen surfaces, thecompositor is still able to scan out directly client surfaces.<br/><br/>
        /// </summary>
        public enum TransformEnum
        {
            Normal = 0,
            k_90 = 1,
            k_180 = 2,
            k_270 = 3,
            Flipped = 4,
            Flipped90 = 5,
            Flipped180 = 6,
            Flipped270 = 7
        }

        /// <summary>
        /// These flags describe properties of an output mode. They areused in the flags bitfield of the mode event.<br/><br/>
        /// </summary>
        public enum ModeEnum
        {
            /// <summary>
            /// indicates this is the current mode<br/><br/>
            /// </summary>
            Current = 0x1,
            /// <summary>
            /// indicates this is the preferred mode<br/><br/>
            /// </summary>
            Preferred = 0x2
        }

        /// <summary>
        /// Describes whether a device is enabled, i.e. device is used todisplay content by the compositor. This wraps a boolean aroundan int to avoid a boolean trap.<br/><br/>
        /// </summary>
        public enum EnablementEnum
        {
            Disabled = 0,
            Enabled = 1
        }

        /// <summary>
        /// Describes what capabilities this device has.<br/><br/>
        /// </summary>
        [Flags]
        public enum CapabilityEnum
        {
            /// <summary>
            /// if this outputdevice can use overscan<br/><br/>
            /// </summary>
            Overscan = 1,
            /// <summary>
            /// if this outputdevice supports variable refresh rate<br/><br/>
            /// </summary>
            Vrr = 2
        }

        /// <summary>
        /// Describes when the compositor may employ variable refresh rate<br/><br/>
        /// </summary>
        public enum VrrPolicyEnum
        {
            Never = 0,
            Always = 1,
            Automatic = 2
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinOutputdevice>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface);
            }

            public OrgKdeKwinOutputdevice Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinOutputdevice(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinOutputdevice> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_outputdevice";
        public const int InterfaceVersion = 4;

        public OrgKdeKwinOutputdevice(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}