using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.Outputmanagement
{
    /// <summary>
    /// This interface enables clients to set properties of output devices for screenconfiguration purposes via the server. To this end output devices are referencedby global org_kde_kwin_outputdevice objects.<br/><br/>
    /// outputmanagement (wl_global)--------------------------request:* create_configuration -&gt; outputconfiguration (wl_resource)<br/><br/>
    /// outputconfiguration (wl_resource)--------------------------requests:* enable(outputdevice, bool)* mode(outputdevice, mode_id)* transformation(outputdevice, flag)* position(outputdevice, x, y)* apply<br/><br/>
    /// events:* applied* failed<br/><br/>
    /// The server registers one outputmanagement object as a global object. In orderto configure outputs a client requests create_configuration, which provides aresource referencing an outputconfiguration for one-time configuration. Thatway the server knows which requests belong together and can group them by that.<br/><br/>
    /// On the outputconfiguration object the client calls for each output whether theoutput should be enabled, which mode should be set (by referencing the mode fromthe list of announced modes) and the output's global position. Once all outputsare configured that way, the client calls apply.At that point and not earlier the server should try to apply the configuration.If this succeeds the server emits the applied signal, otherwise the failedsignal, such that the configuring client is noticed about the success of itsconfiguration request.<br/><br/>
    /// Through this design the interface enables atomic output configuration changes ifinternally supported by the server.<br/><br/>
    /// <br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinOutputmanagement : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinOutputmanagement()
        {
            NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputmanagement.WlInterface = new WlInterface("org_kde_kwin_outputmanagement", 4, new WlMessage[] {
                new WlMessage("create_configuration", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputmanagement.WlInterface);
        }

        /// <summary>
        /// Request an outputconfiguration object through which the client can configureoutput devices.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration CreateConfiguration()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinOutputmanagement>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputmanagement.WlInterface);
            }

            public OrgKdeKwinOutputmanagement Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinOutputmanagement(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinOutputmanagement> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_outputmanagement";
        public const int InterfaceVersion = 4;

        public OrgKdeKwinOutputmanagement(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// outputconfiguration is a client-specific resource that can be used to askthe server to apply changes to available output devices.<br/><br/>
    /// The client receives a list of output devices from the registry. When it wantsto apply new settings, it creates a configuration object from theoutputmanagement global, writes changes through this object's enable, scale,transform and mode calls. It then asks the server to apply these settings inan atomic fashion, for example through Linux' DRM interface.<br/><br/>
    /// The server signals back whether the new settings have applied successfullyor failed to apply. outputdevice objects are updated after the changes have beenapplied to the hardware and before the server side sends the applied event.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinOutputconfiguration : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinOutputconfiguration()
        {
            NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration.WlInterface = new WlInterface("org_kde_kwin_outputconfiguration", 4, new WlMessage[] {
                new WlMessage("enable", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("mode", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("transform", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("position", "oii", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null, null }),
                new WlMessage("scale", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("apply", "", new WlInterface*[] { }),
                new WlMessage("scalef", "2of", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("colorcurves", "2oaaa", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null, null, null }),
                new WlMessage("destroy", "2", new WlInterface*[] { }),
                new WlMessage("overscan", "3ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null }),
                new WlMessage("set_vrr_policy", "4ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice.WlInterface), null })
            }, new WlMessage[] {
                new WlMessage("applied", "", new WlInterface*[] { }),
                new WlMessage("failed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration.WlInterface);
        }

        /// <summary>
        /// Mark the output as enabled or disabled.<br/><br/>
        /// </summary>
        public void Enable(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, int @enable)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @enable
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Sets the mode for a given output by its mode size (width and height) and refresh rate.<br/><br/>
        /// </summary>
        public void Mode(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, int @modeId)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @modeId
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Sets the transformation for a given output.<br/><br/>
        /// </summary>
        public void Transform(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, int @transform)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @transform
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Sets the position for this output device. (x,y) describe the top-left cornerof the output in global space, whereby the origin (0,0) of the global spacehas to be aligned with the top-left corner of the most left and in case thisdoes not define a single one the top output.<br/><br/>
        /// There may be no gaps or overlaps between outputs, i.e. the outputs arestacked horizontally, vertically, or both on each other.<br/><br/>
        /// </summary>
        public void Position(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, int @x, int @y)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Sets the scaling factor for this output device.<br/><br/>
        /// </summary>
        public void Scale(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, int @scale)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @scale
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Asks the server to apply property changes requested through this outputconfigurationobject to all outputs on the server side.<br/><br/>
        /// </summary>
        public void Apply()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Sets the scaling factor for this output device.Sending both scale and scalef is undefined.<br/><br/>
        /// </summary>
        public void Scalef(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, WlFixed @scale)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            if (Version < 2)
                throw new InvalidOperationException("Request scalef is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @scale
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        /// <summary>
        /// Set color curves of output devices through RGB color ramps. Allows colorcorrection of output device from user space.<br/><br/>
        /// These are the raw values. A compositor might opt to adjust these valuesinternally, for example to shift color temperature at night.<br/><br/>
        /// </summary>
        public void Colorcurves(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, ReadOnlySpan<byte> @red, ReadOnlySpan<byte> @green, ReadOnlySpan<byte> @blue)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            if (Version < 2)
                throw new InvalidOperationException("Request colorcurves is only supported since version 2");
            fixed (byte* __pointer__red = @red)
            fixed (byte* __pointer__green = @green)
            fixed (byte* __pointer__blue = @blue)
            {
                var __marshalled__red = WlArray.FromPointer(__pointer__red, @red.Length);
                var __marshalled__green = WlArray.FromPointer(__pointer__green, @green.Length);
                var __marshalled__blue = WlArray.FromPointer(__pointer__blue, @blue.Length);
                WlArgument* __args = stackalloc WlArgument[] {
                    @outputdevice,
                    &__marshalled__red,
                    &__marshalled__green,
                    &__marshalled__blue
                };
                LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 2)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Set the overscan value of this output device with a value in percent.<br/><br/>
        /// </summary>
        public void Overscan(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, uint @overscan)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            if (Version < 3)
                throw new InvalidOperationException("Request overscan is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @overscan
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        /// <summary>
        /// Set what policy the compositor should employ regarding its use ofvariable refresh rate.<br/><br/>
        /// </summary>
        public void SetVrrPolicy(NWayland.Protocols.Plasma.OrgKdeKwinOutputdevice.OrgKdeKwinOutputdevice @outputdevice, VrrPolicyEnum @policy)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            if (Version < 4)
                throw new InvalidOperationException("Request set_vrr_policy is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                (uint)@policy
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent after the server has successfully applied the changes..<br/><br/>
            /// </summary>
            void OnApplied(NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration eventSender);

            /// <summary>
            /// Sent if the server rejects the changes or failed to apply them.<br/><br/>
            /// </summary>
            void OnFailed(NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnApplied(this);
                    break;
                case 1:
                    Events?.OnFailed(this);
                    break;
            }
        }

        /// <summary>
        /// Describes when the compositor may employ variable refresh rate<br/><br/>
        /// </summary>
        public enum VrrPolicyEnum
        {
            Never = 0,
            Always = 1,
            Automatic = 2
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinOutputconfiguration>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Outputmanagement.OrgKdeKwinOutputconfiguration.WlInterface);
            }

            public OrgKdeKwinOutputconfiguration Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinOutputconfiguration(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinOutputconfiguration> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_outputconfiguration";
        public const int InterfaceVersion = 4;

        public OrgKdeKwinOutputconfiguration(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}