using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.Dpms
{
    /// <summary>
    /// The Dpms manager allows to get a org_kde_kwin_dpms for a given wl_output.The org_kde_kwin_dpms provides the currently used VESA Display Power ManagementSignaling state (see https://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling ).In addition it allows to request a state change. A compositor is not obliged to honor itand will normally automatically switch back to on state.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinDpmsManager : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinDpmsManager()
        {
            NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpmsManager.WlInterface = new WlInterface("org_kde_kwin_dpms_manager", 1, new WlMessage[] {
                new WlMessage("get", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpmsManager.WlInterface);
        }

        /// <summary>
        /// Factory request to get the org_kde_kwin_dpms for a given wl_output.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms Get(NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @output
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinDpmsManager>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpmsManager.WlInterface);
            }

            public OrgKdeKwinDpmsManager Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinDpmsManager(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinDpmsManager> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_dpms_manager";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinDpmsManager(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This interface provides information about the VESA DPMS state for a wl_output.It gets created through the request get on the org_kde_kwin_dpms_manager interface.<br/><br/>
    /// On creating the resource the server will push whether DPSM is supported for the output,the currently used DPMS state and notifies the client through the done event once allstates are pushed. Whenever a state changes the set of changes is committed with thedone event.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinDpms : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinDpms()
        {
            NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms.WlInterface = new WlInterface("org_kde_kwin_dpms", 1, new WlMessage[] {
                new WlMessage("set", "u", new WlInterface*[] { null }),
                new WlMessage("release", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("supported", "u", new WlInterface*[] { null }),
                new WlMessage("mode", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms.WlInterface);
        }

        /// <summary>
        /// Requests that the compositor puts the wl_output into the passed mode. The compositoris not obliged to change the state. In addition the compositor might leave the modewhenever it seems suitable. E.g. the compositor might return to On state on user input.<br/><br/>
        /// The client should not assume that the mode changed after requesting a new mode.Instead the client should listen for the mode event.<br/><br/>
        /// </summary>
        public void Set(uint @mode)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @mode
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event gets pushed on binding the resource and indicates whether the wl_outputsupports DPMS. There are operation modes of a Wayland server where DPMS might notmake sense (e.g. nested compositors).<br/><br/>
            /// </summary>
            void OnSupported(NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms eventSender, uint @supported);

            /// <summary>
            /// This mode gets pushed on binding the resource and provides the currently usedDPMS mode. It also gets pushed if DPMS is not supported for the wl_output, in thatcase the value will be On.<br/><br/>
            /// The event is also pushed whenever the state changes.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms eventSender, uint @mode);

            /// <summary>
            /// This event gets pushed on binding the resource once all other states are pushed.<br/><br/>
            /// In addition it gets pushed whenever a state changes to tell the client that allstate changes have been pushed.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSupported(this, arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnMode(this, arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnDone(this);
                    break;
            }
        }

        public enum ModeEnum
        {
            On = 0,
            Standby = 1,
            Suspend = 2,
            Off = 3
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinDpms>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Dpms.OrgKdeKwinDpms.WlInterface);
            }

            public OrgKdeKwinDpms Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinDpms(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinDpms> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_dpms";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinDpms(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}