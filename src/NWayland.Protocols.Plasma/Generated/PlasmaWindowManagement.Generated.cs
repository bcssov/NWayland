using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.PlasmaWindowManagement
{
    /// <summary>
    /// This interface manages application windows.It provides requests to show and hide the desktop and emitsan event every time a window is created so that the client canuse it to manage the window.<br/><br/>
    /// Only one client can bind this interface at a time.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdePlasmaWindowManagement : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaWindowManagement()
        {
            NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement.WlInterface = new WlInterface("org_kde_plasma_window_management", 16, new WlMessage[] {
                new WlMessage("show_desktop", "u", new WlInterface*[] { null }),
                new WlMessage("get_window", "nu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface), null }),
                new WlMessage("get_window_by_uuid", "12ns", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface), null })
            }, new WlMessage[] {
                new WlMessage("show_desktop_changed", "u", new WlInterface*[] { null }),
                new WlMessage("window", "u", new WlInterface*[] { null }),
                new WlMessage("stacking_order_changed", "11a", new WlInterface*[] { null }),
                new WlMessage("stacking_order_uuid_changed", "12s", new WlInterface*[] { null }),
                new WlMessage("window_with_uuid", "13us", new WlInterface*[] { null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement.WlInterface);
        }

        /// <summary>
        /// Tell the compositor to show/hide the desktop.<br/><br/>
        /// </summary>
        public void ShowDesktop(uint @state)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @state
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Deprecated: use get_window_by_uuid<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow GetWindow(uint @internalWindowId)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @internalWindowId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow(__ret, Version);
        }

        public NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow GetWindowByUuid(string @internalWindowUuid)
        {
            if (@internalWindowUuid == null)
                throw new ArgumentNullException("internalWindowUuid");
            if (Version < 12)
                throw new InvalidOperationException("Request get_window_by_uuid is only supported since version 12");
            using var __marshalled__internalWindowUuid = new NWaylandMarshalledString(@internalWindowUuid);
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                __marshalled__internalWindowUuid
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 2, __args, ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event will be sent whenever the show desktop mode changes. E.g. when it is enteredor left.<br/><br/>
            /// On binding the interface the current state is sent.<br/><br/>
            /// </summary>
            void OnShowDesktopChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement eventSender, uint @state);

            /// <summary>
            /// This event will be sent immediately after a window is mapped.<br/><br/>
            /// </summary>
            void OnWindow(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement eventSender, uint @id);

            /// <summary>
            /// This event will be sent when stacking order changed and on bind<br/><br/>
            /// </summary>
            void OnStackingOrderChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement eventSender, ReadOnlySpan<byte> @ids);

            /// <summary>
            /// This event will be sent when stacking order changed and on bind<br/><br/>
            /// </summary>
            void OnStackingOrderUuidChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement eventSender, string @uuids);

            /// <summary>
            /// This event will be sent immediately after a window is mapped.<br/><br/>
            /// </summary>
            void OnWindowWithUuid(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement eventSender, uint @id, string @uuid);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnShowDesktopChanged(this, arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnWindow(this, arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnStackingOrderChanged(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnStackingOrderUuidChanged(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 4:
                    Events?.OnWindowWithUuid(this, arguments[0].UInt32, Marshal.PtrToStringAnsi(arguments[1].IntPtr));
                    break;
            }
        }

        public enum StateEnum
        {
            Active = 1 << 0,
            Minimized = 1 << 1,
            Maximized = 1 << 2,
            Fullscreen = 1 << 3,
            KeepAbove = 1 << 4,
            KeepBelow = 1 << 5,
            OnAllDesktops = 1 << 6,
            DemandsAttention = 1 << 7,
            Closeable = 1 << 8,
            Minimizable = 1 << 9,
            Maximizable = 1 << 10,
            Fullscreenable = 1 << 11,
            Skiptaskbar = 1 << 12,
            Shadeable = 1 << 13,
            Shaded = 1 << 14,
            Movable = 1 << 15,
            Resizable = 1 << 16,
            VirtualDesktopChangeable = 1 << 17,
            Skipswitcher = 1 << 18
        }

        public enum ShowDesktopEnum
        {
            Disabled = 0,
            Enabled = 1
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaWindowManagement>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindowManagement.WlInterface);
            }

            public OrgKdePlasmaWindowManagement Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaWindowManagement(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaWindowManagement> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_window_management";
        public const int InterfaceVersion = 16;

        public OrgKdePlasmaWindowManagement(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// Manages and control an application window.<br/><br/>
    /// Only one client can bind this interface at a time.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdePlasmaWindow : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaWindow()
        {
            NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface = new WlInterface("org_kde_plasma_window", 16, new WlMessage[] {
                new WlMessage("set_state", "uu", new WlInterface*[] { null, null }),
                new WlMessage("set_virtual_desktop", "u", new WlInterface*[] { null }),
                new WlMessage("set_minimized_geometry", "ouuuu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, null, null }),
                new WlMessage("unset_minimized_geometry", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("close", "", new WlInterface*[] { }),
                new WlMessage("request_move", "3", new WlInterface*[] { }),
                new WlMessage("request_resize", "3", new WlInterface*[] { }),
                new WlMessage("destroy", "4", new WlInterface*[] { }),
                new WlMessage("get_icon", "7h", new WlInterface*[] { null }),
                new WlMessage("request_enter_virtual_desktop", "8s", new WlInterface*[] { null }),
                new WlMessage("request_enter_new_virtual_desktop", "8", new WlInterface*[] { }),
                new WlMessage("request_leave_virtual_desktop", "8s", new WlInterface*[] { null }),
                new WlMessage("request_enter_activity", "14s", new WlInterface*[] { null }),
                new WlMessage("request_leave_activity", "14s", new WlInterface*[] { null }),
                new WlMessage("send_to_output", "15o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("title_changed", "s", new WlInterface*[] { null }),
                new WlMessage("app_id_changed", "s", new WlInterface*[] { null }),
                new WlMessage("state_changed", "u", new WlInterface*[] { null }),
                new WlMessage("virtual_desktop_changed", "i", new WlInterface*[] { null }),
                new WlMessage("themed_icon_name_changed", "s", new WlInterface*[] { null }),
                new WlMessage("unmapped", "", new WlInterface*[] { }),
                new WlMessage("initial_state", "4", new WlInterface*[] { }),
                new WlMessage("parent_window", "5?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface) }),
                new WlMessage("geometry", "6iiuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("icon_changed", "7", new WlInterface*[] { }),
                new WlMessage("pid_changed", "u", new WlInterface*[] { null }),
                new WlMessage("virtual_desktop_entered", "8s", new WlInterface*[] { null }),
                new WlMessage("virtual_desktop_left", "8s", new WlInterface*[] { null }),
                new WlMessage("application_menu", "10ss", new WlInterface*[] { null, null }),
                new WlMessage("activity_entered", "14s", new WlInterface*[] { null }),
                new WlMessage("activity_left", "14s", new WlInterface*[] { null }),
                new WlMessage("resource_name_changed", "16s", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface);
        }

        /// <summary>
        /// Set window state.<br/><br/>
        /// Values for state argument are described by org_kde_plasma_window_management.stateand can be used together in a bitfield. The flags bitfield describes which flags aresupposed to be set, the state bitfield the value for the set flags<br/><br/>
        /// </summary>
        public void SetState(uint @flags, uint @state)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @flags,
                @state
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Deprecated: use enter_virtual_desktopMaps the window to a different virtual desktop.<br/><br/>
        /// To show the window on all virtual desktops, call theorg_kde_plasma_window.set_state request and specify a on_all_desktopsstate in the bitfield.<br/><br/>
        /// </summary>
        public void SetVirtualDesktop(uint @number)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @number
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Sets the geometry of the taskbar entry for this window.The geometry is relative to a panel in particular.<br/><br/>
        /// </summary>
        public void SetMinimizedGeometry(NWayland.Protocols.Wayland.WlSurface @panel, uint @x, uint @y, uint @width, uint @height)
        {
            if (@panel == null)
                throw new ArgumentNullException("panel");
            WlArgument* __args = stackalloc WlArgument[] {
                @panel,
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Remove the task geometry information for a particular panel.<br/><br/>
        /// </summary>
        public void UnsetMinimizedGeometry(NWayland.Protocols.Wayland.WlSurface @panel)
        {
            if (@panel == null)
                throw new ArgumentNullException("panel");
            WlArgument* __args = stackalloc WlArgument[] {
                @panel
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Close this window.<br/><br/>
        /// </summary>
        public void Close()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Request an interactive move for this window.<br/><br/>
        /// </summary>
        public void RequestMove()
        {
            if (Version < 3)
                throw new InvalidOperationException("Request request_move is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Request an interactive resize for this window.<br/><br/>
        /// </summary>
        public void RequestResize()
        {
            if (Version < 3)
                throw new InvalidOperationException("Request request_resize is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 4)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// The compositor will write the window icon into the provided file descriptor.The data is a serialized QIcon with QDataStream.<br/><br/>
        /// </summary>
        public void GetIcon(int @fd)
        {
            if (Version < 7)
                throw new InvalidOperationException("Request get_icon is only supported since version 7");
            WlArgument* __args = stackalloc WlArgument[] {
                @fd
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// Make the window enter a virtual desktop. A window can enter morethan one virtual desktop. if the id is empty or invalid, no action will be performed.<br/><br/>
        /// </summary>
        public void RequestEnterVirtualDesktop(string @id)
        {
            if (@id == null)
                throw new ArgumentNullException("id");
            if (Version < 8)
                throw new InvalidOperationException("Request request_enter_virtual_desktop is only supported since version 8");
            using var __marshalled__id = new NWaylandMarshalledString(@id);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__id
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        /// <summary>
        /// RFC: do this with an empty id to request_enter_virtual_desktop?Make the window enter a new virtual desktop. If the server consents the request,it will create a new virtual desktop and assign the window to it.<br/><br/>
        /// </summary>
        public void RequestEnterNewVirtualDesktop()
        {
            if (Version < 8)
                throw new InvalidOperationException("Request request_enter_new_virtual_desktop is only supported since version 8");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        /// <summary>
        /// Make the window exit a virtual desktop. If it exits all desktops it will be considered on all of them.<br/><br/>
        /// </summary>
        public void RequestLeaveVirtualDesktop(string @id)
        {
            if (@id == null)
                throw new ArgumentNullException("id");
            if (Version < 8)
                throw new InvalidOperationException("Request request_leave_virtual_desktop is only supported since version 8");
            using var __marshalled__id = new NWaylandMarshalledString(@id);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__id
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 11, __args);
        }

        /// <summary>
        /// Make the window enter an activity. A window can enter more activity. If the id is empty or invalid, no action will be performed.<br/><br/>
        /// </summary>
        public void RequestEnterActivity(string @id)
        {
            if (@id == null)
                throw new ArgumentNullException("id");
            if (Version < 14)
                throw new InvalidOperationException("Request request_enter_activity is only supported since version 14");
            using var __marshalled__id = new NWaylandMarshalledString(@id);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__id
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 12, __args);
        }

        /// <summary>
        /// Make the window exit a an activity. If it exits all activities it will be considered on all of them.<br/><br/>
        /// </summary>
        public void RequestLeaveActivity(string @id)
        {
            if (@id == null)
                throw new ArgumentNullException("id");
            if (Version < 14)
                throw new InvalidOperationException("Request request_leave_activity is only supported since version 14");
            using var __marshalled__id = new NWaylandMarshalledString(@id);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__id
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 13, __args);
        }

        /// <summary>
        /// Requests this window to be displayed in a specific output.<br/><br/>
        /// </summary>
        public void SendToOutput(NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            if (Version < 15)
                throw new InvalidOperationException("Request send_to_output is only supported since version 15");
            WlArgument* __args = stackalloc WlArgument[] {
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 14, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event will be sent as soon as the window title is changed.<br/><br/>
            /// </summary>
            void OnTitleChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @title);

            /// <summary>
            /// This event will be sent as soon as the applicationidentifier is changed.<br/><br/>
            /// </summary>
            void OnAppIdChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @appId);

            /// <summary>
            /// This event will be sent as soon as the window state changes.<br/><br/>
            /// Values for state argument are described by org_kde_plasma_window_management.state.<br/><br/>
            /// </summary>
            void OnStateChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, uint @flags);

            /// <summary>
            /// DEPRECATED: use virtual_desktop_entered and virtual_desktop_left insteadThis event will be sent when a window is moved to anothervirtual desktop.<br/><br/>
            /// It is not sent if it becomes visible on all virtual desktops though.<br/><br/>
            /// </summary>
            void OnVirtualDesktopChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, int @number);

            /// <summary>
            /// This event will be sent whenever the themed icon name changes. May be null.<br/><br/>
            /// </summary>
            void OnThemedIconNameChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @name);

            /// <summary>
            /// This event will be sent immediately after the window is closedand its surface is unmapped.<br/><br/>
            /// </summary>
            void OnUnmapped(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender);

            /// <summary>
            /// This event will be sent immediately after all initial state been sent to the client.If the Plasma window is already unmapped, the unmapped event will be sent before theinitial_state event.<br/><br/>
            /// </summary>
            void OnInitialState(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender);

            /// <summary>
            /// This event will be sent whenever the parent window of this org_kde_plasma_window changes.The passed parent is another org_kde_plasma_window and this org_kde_plasma_window is atransient window to the parent window. If the parent argument is null, thisorg_kde_plasma_window does not have a parent window.<br/><br/>
            /// </summary>
            void OnParentWindow(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow? @parent);

            /// <summary>
            /// This event will be sent whenever the window geometry of this org_kde_plasma_window changes.The coordinates are in absolute coordinates of the windowing system.<br/><br/>
            /// </summary>
            void OnGeometry(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, int @x, int @y, uint @width, uint @height);

            /// <summary>
            /// This event will be sent whenever the icon of the window changes, but there is no themedicon name. Common examples are Xwayland windows which have a pixmap based icon.<br/><br/>
            /// The client can request the icon using get_icon.<br/><br/>
            /// </summary>
            void OnIconChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender);

            /// <summary>
            /// This event will be sent when the compositor has set the process id this window belongs to.This should be set once before the initial_state is sent.<br/><br/>
            /// </summary>
            void OnPidChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, uint @pid);

            /// <summary>
            /// This event will be sent when the window has entered a new virtual desktop. The window can be on more than one desktop, or none: then is considered on all of them.<br/><br/>
            /// </summary>
            void OnVirtualDesktopEntered(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @id);

            /// <summary>
            /// This event will be sent when the window left a virtual desktop. If the window leaves all desktops, it can be considered on all.If the window gets manually added on all desktops, the server has to send virtual_desktop_left for every previous desktop it was in for the window to be really considered on all desktops.<br/><br/>
            /// </summary>
            void OnVirtualDesktopLeft(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @is);

            /// <summary>
            /// This event will be sent after the application menufor the window has changed.<br/><br/>
            /// </summary>
            void OnApplicationMenu(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @serviceName, string @objectPath);

            /// <summary>
            /// This event will be sent when the window has entered an activity. The window can be on more than one activity, or none: then is considered on all of them.<br/><br/>
            /// </summary>
            void OnActivityEntered(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @id);

            /// <summary>
            /// This event will be sent when the window left an activity. If the window leaves all activities, it will be considered on all.If the window gets manually added on all activities, the server has to send activity_left for every previous activity it was in for the window to be really considered on all activities.<br/><br/>
            /// </summary>
            void OnActivityLeft(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @id);

            /// <summary>
            /// This event will be sent when the X11 resource name of the window has changed.This is only set for XWayland windows.<br/><br/>
            /// </summary>
            void OnResourceNameChanged(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow eventSender, string @resourceName);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnTitleChanged(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnAppIdChanged(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnStateChanged(this, arguments[0].UInt32);
                    break;
                case 3:
                    Events?.OnVirtualDesktopChanged(this, arguments[0].Int32);
                    break;
                case 4:
                    Events?.OnThemedIconNameChanged(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 5:
                    Events?.OnUnmapped(this);
                    break;
                case 6:
                    Events?.OnInitialState(this);
                    break;
                case 7:
                    Events?.OnParentWindow(this, WlProxy.FromNative<NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow>(arguments[0].IntPtr));
                    break;
                case 8:
                    Events?.OnGeometry(this, arguments[0].Int32, arguments[1].Int32, arguments[2].UInt32, arguments[3].UInt32);
                    break;
                case 9:
                    Events?.OnIconChanged(this);
                    break;
                case 10:
                    Events?.OnPidChanged(this, arguments[0].UInt32);
                    break;
                case 11:
                    Events?.OnVirtualDesktopEntered(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 12:
                    Events?.OnVirtualDesktopLeft(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 13:
                    Events?.OnApplicationMenu(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr), Marshal.PtrToStringAnsi(arguments[1].IntPtr));
                    break;
                case 14:
                    Events?.OnActivityEntered(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 15:
                    Events?.OnActivityLeft(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 16:
                    Events?.OnResourceNameChanged(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaWindow>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaWindow.WlInterface);
            }

            public OrgKdePlasmaWindow Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaWindow(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaWindow> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_window";
        public const int InterfaceVersion = 16;

        public OrgKdePlasmaWindow(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The activation manager interface provides a way to get notifiedwhen an application is about to be activated.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdePlasmaActivationFeedback : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaActivationFeedback()
        {
            NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivationFeedback.WlInterface = new WlInterface("org_kde_plasma_activation_feedback", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("activation", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivationFeedback.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Will be issued when an app is set to be activated. It offersan instance of org_kde_plasma_activation that will tell us the app_idand the extent of the activation.<br/><br/>
            /// </summary>
            void OnActivation(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivationFeedback eventSender, OrgKdePlasmaActivation @id);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnActivation(this, new OrgKdePlasmaActivation(arguments[0].IntPtr, Version));
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaActivationFeedback>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivationFeedback.WlInterface);
            }

            public OrgKdePlasmaActivationFeedback Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaActivationFeedback(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaActivationFeedback> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_activation_feedback";
        public const int InterfaceVersion = 1;

        public OrgKdePlasmaActivationFeedback(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    public sealed unsafe partial class OrgKdePlasmaActivation : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaActivation()
        {
            NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation.WlInterface = new WlInterface("org_kde_plasma_activation", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("app_id", "s", new WlInterface*[] { null }),
                new WlMessage("finished", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            void OnAppId(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation eventSender, string @appId);
            void OnFinished(NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnAppId(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnFinished(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaActivation>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaWindowManagement.OrgKdePlasmaActivation.WlInterface);
            }

            public OrgKdePlasmaActivation Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaActivation(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaActivation> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_activation";
        public const int InterfaceVersion = 1;

        public OrgKdePlasmaActivation(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}