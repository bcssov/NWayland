using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.KdeOutputDeviceV2
{
    /// <summary>
    /// An output device describes a display device available to the compositor.output_device is similar to wl_output, but focuses on outputconfiguration management.A client can query all global output_device objects to enlist allavailable display devices, even those that may currently not berepresented by the compositor as a wl_output.The client sends configuration changes to the server through theoutputconfiguration interface, and the server applies the configurationchanges to the hardware and signals changes to the output devicesaccordingly.This object is published as global during start up for every availabledisplay devices, or when one later becomes available, for example bybeing hotplugged via a physical connector.<br/><br/>
    /// </summary>
    public sealed unsafe partial class KdeOutputDeviceV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static KdeOutputDeviceV2()
        {
            NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface = new WlInterface("kde_output_device_v2", 2, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("geometry", "iiiiissi", new WlInterface*[] { null, null, null, null, null, null, null, null }),
                new WlMessage("current_mode", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface) }),
                new WlMessage("mode", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface) }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("scale", "f", new WlInterface*[] { null }),
                new WlMessage("edid", "s", new WlInterface*[] { null }),
                new WlMessage("enabled", "i", new WlInterface*[] { null }),
                new WlMessage("uuid", "s", new WlInterface*[] { null }),
                new WlMessage("serial_number", "s", new WlInterface*[] { null }),
                new WlMessage("eisa_id", "s", new WlInterface*[] { null }),
                new WlMessage("capabilities", "u", new WlInterface*[] { null }),
                new WlMessage("overscan", "u", new WlInterface*[] { null }),
                new WlMessage("vrr_policy", "u", new WlInterface*[] { null }),
                new WlMessage("rgb_range", "u", new WlInterface*[] { null }),
                new WlMessage("name", "2s", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// The geometry event describes geometric properties of the output.The event is sent when binding to the output object and wheneverany of the properties change.<br/><br/>
            /// </summary>
            void OnGeometry(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, int @x, int @y, int @physicalWidth, int @physicalHeight, int @subpixel, string @make, string @model, int @transform);

            /// <summary>
            /// This event describes the mode currently in use for this head. It is onlysent if the output is enabled.<br/><br/>
            /// </summary>
            void OnCurrentMode(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 @mode);

            /// <summary>
            /// The mode event describes an available mode for the output.When the client binds to the output_device object, the server sends thisevent once for every available mode the output_device can be operated by.There will always be at least one event sent out on initial binding,which represents the current mode.Later if an output changes, its mode event is sent again for theeventual added modes and lastly the current mode. In other words, thecurrent mode is always represented by the latest event sent with the currentflag set.The size of a mode is given in physical hardware units of the output device.This is not necessarily the same as the output size in the global compositorspace. For instance, the output may be scaled, as described inkde_output_device_v2.scale, or transformed, as described inkde_output_device_v2.transform.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, KdeOutputDeviceModeV2 @mode);

            /// <summary>
            /// This event is sent after all other properties have beensent on binding to the output object as well as after anyother output property change have been applied later on.This allows to see changes to the output properties as atomic,even if multiple events successively announce them.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender);

            /// <summary>
            /// This event contains scaling geometry informationthat is not in the geometry event. It may be sent afterbinding the output object or if the output scale changeslater. If it is not sent, the client should assume ascale of 1.A scale larger than 1 means that the compositor willautomatically scale surface buffers by this amountwhen rendering. This is used for high resolutiondisplays where applications rendering at the nativeresolution would be too small to be legible.It is intended that scaling aware clients track thecurrent output of a surface, and if it is on a scaledoutput it should use wl_surface.set_buffer_scale withthe scale of the output. That way the compositor canavoid scaling the surface, and the client can supplya higher detail image.<br/><br/>
            /// </summary>
            void OnScale(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, WlFixed @factor);

            /// <summary>
            /// The edid event encapsulates the EDID data for the outputdevice.The event is sent when binding to the output object. The EDIDdata may be empty, in which case this event is sent anyway.If the EDID information is empty, you can fall back to the nameet al. properties of the outputdevice.<br/><br/>
            /// </summary>
            void OnEdid(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, string @raw);

            /// <summary>
            /// The enabled event notifies whether this output is currentlyenabled and used for displaying content by the server.The event is sent when binding to the output object andwhenever later on an output changes its state by becomingenabled or disabled.<br/><br/>
            /// </summary>
            void OnEnabled(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, int @enabled);

            /// <summary>
            /// The uuid can be used to identify the output. It's controlled bythe server entirely. The server should make sure the uuid ispersistent across restarts. An empty uuid is considered invalid.<br/><br/>
            /// </summary>
            void OnUuid(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, string @uuid);

            /// <summary>
            /// Serial ID of the monitor, sent on startup before the first done event.<br/><br/>
            /// </summary>
            void OnSerialNumber(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, string @serialNumber);

            /// <summary>
            /// EISA ID of the monitor, sent on startup before the first done event.<br/><br/>
            /// </summary>
            void OnEisaId(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, string @eisaId);

            /// <summary>
            /// What capabilities this device has, sent on startup before the firstdone event.<br/><br/>
            /// </summary>
            void OnCapabilities(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, CapabilityEnum @flags);

            /// <summary>
            /// Overscan value of the monitor in percent, sent on startup before thefirst done event.<br/><br/>
            /// </summary>
            void OnOverscan(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, uint @overscan);

            /// <summary>
            /// What policy the compositor will employ regarding its use of variablerefresh rate.<br/><br/>
            /// </summary>
            void OnVrrPolicy(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, VrrPolicyEnum @vrrPolicy);

            /// <summary>
            /// What rgb range the compositor is using for this output<br/><br/>
            /// </summary>
            void OnRgbRange(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, RgbRangeEnum @rgbRange);

            /// <summary>
            /// Name of the output, it's useful to cross-reference to an zxdg_output_v1 and ultimately QScreen<br/><br/>
            /// </summary>
            void OnName(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 eventSender, string @name);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGeometry(this, arguments[0].Int32, arguments[1].Int32, arguments[2].Int32, arguments[3].Int32, arguments[4].Int32, Marshal.PtrToStringAnsi(arguments[5].IntPtr), Marshal.PtrToStringAnsi(arguments[6].IntPtr), arguments[7].Int32);
                    break;
                case 1:
                    Events?.OnCurrentMode(this, WlProxy.FromNative<NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2>(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnMode(this, new KdeOutputDeviceModeV2(arguments[0].IntPtr, Version));
                    break;
                case 3:
                    Events?.OnDone(this);
                    break;
                case 4:
                    Events?.OnScale(this, arguments[0].WlFixed);
                    break;
                case 5:
                    Events?.OnEdid(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 6:
                    Events?.OnEnabled(this, arguments[0].Int32);
                    break;
                case 7:
                    Events?.OnUuid(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 8:
                    Events?.OnSerialNumber(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 9:
                    Events?.OnEisaId(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 10:
                    Events?.OnCapabilities(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
                case 11:
                    Events?.OnOverscan(this, arguments[0].UInt32);
                    break;
                case 12:
                    Events?.OnVrrPolicy(this, (VrrPolicyEnum)arguments[0].UInt32);
                    break;
                case 13:
                    Events?.OnRgbRange(this, (RgbRangeEnum)arguments[0].UInt32);
                    break;
                case 14:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
            }
        }

        /// <summary>
        /// This enumeration describes how the physical pixels on an output arelaid out.<br/><br/>
        /// </summary>
        public enum SubpixelEnum
        {
            Unknown = 0,
            None = 1,
            HorizontalRgb = 2,
            HorizontalBgr = 3,
            VerticalRgb = 4,
            VerticalBgr = 5
        }

        /// <summary>
        /// This describes the transform, that a compositor will apply to asurface to compensate for the rotation or mirroring of anoutput device.The flipped values correspond to an initial flip around avertical axis followed by rotation.The purpose is mainly to allow clients to render accordingly andtell the compositor, so that for fullscreen surfaces, thecompositor is still able to scan out directly client surfaces.<br/><br/>
        /// </summary>
        public enum TransformEnum
        {
            Normal = 0,
            k_90 = 1,
            k_180 = 2,
            k_270 = 3,
            Flipped = 4,
            Flipped90 = 5,
            Flipped180 = 6,
            Flipped270 = 7
        }

        /// <summary>
        /// Describes what capabilities this device has.<br/><br/>
        /// </summary>
        [Flags]
        public enum CapabilityEnum
        {
            /// <summary>
            /// if this output_device can use overscan<br/><br/>
            /// </summary>
            Overscan = 1,
            /// <summary>
            /// if this outputdevice supports variable refresh rate<br/><br/>
            /// </summary>
            Vrr = 2,
            /// <summary>
            /// if setting the rgb range is possible<br/><br/>
            /// </summary>
            RgbRange = 4
        }

        /// <summary>
        /// Describes when the compositor may employ variable refresh rate<br/><br/>
        /// </summary>
        public enum VrrPolicyEnum
        {
            Never = 0,
            Always = 1,
            Automatic = 2
        }

        /// <summary>
        /// Whether full or limited color range should be used<br/><br/>
        /// </summary>
        public enum RgbRangeEnum
        {
            Automatic = 0,
            Full = 1,
            Limited = 2
        }

        private class ProxyFactory : IBindFactory<KdeOutputDeviceV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface);
            }

            public KdeOutputDeviceV2 Create(IntPtr handle, int version)
            {
                return new KdeOutputDeviceV2(handle, version);
            }
        }

        public static IBindFactory<KdeOutputDeviceV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "kde_output_device_v2";
        public const int InterfaceVersion = 2;

        public KdeOutputDeviceV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object describes an output mode.<br/><br/>
    /// Some heads don't support output modes, in which case modes won't beadvertised.<br/><br/>
    /// Properties sent via this interface are applied atomically via thekde_output_device.done event. No guarantees are made regarding the orderin which properties are sent.<br/><br/>
    /// </summary>
    public sealed unsafe partial class KdeOutputDeviceModeV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static KdeOutputDeviceModeV2()
        {
            NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface = new WlInterface("kde_output_device_mode_v2", 1, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("size", "ii", new WlInterface*[] { null, null }),
                new WlMessage("refresh", "i", new WlInterface*[] { null }),
                new WlMessage("preferred", "", new WlInterface*[] { }),
                new WlMessage("removed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event describes the mode size. The size is given in physicalhardware units of the output device. This is not necessarily the same asthe output size in the global compositor space. For instance, the outputmay be scaled or transformed.<br/><br/>
            /// </summary>
            void OnSize(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 eventSender, int @width, int @height);

            /// <summary>
            /// This event describes the mode's fixed vertical refresh rate. It is onlysent if the mode has a fixed refresh rate.<br/><br/>
            /// </summary>
            void OnRefresh(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 eventSender, int @refresh);

            /// <summary>
            /// This event advertises this mode as preferred.<br/><br/>
            /// </summary>
            void OnPreferred(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 eventSender);

            /// <summary>
            /// The compositor will destroy the object immediately after sending thisevent, so it will become invalid and the client should release anyresources associated with it.<br/><br/>
            /// </summary>
            void OnRemoved(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSize(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 1:
                    Events?.OnRefresh(this, arguments[0].Int32);
                    break;
                case 2:
                    Events?.OnPreferred(this);
                    break;
                case 3:
                    Events?.OnRemoved(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<KdeOutputDeviceModeV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface);
            }

            public KdeOutputDeviceModeV2 Create(IntPtr handle, int version)
            {
                return new KdeOutputDeviceModeV2(handle, version);
            }
        }

        public static IBindFactory<KdeOutputDeviceModeV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "kde_output_device_mode_v2";
        public const int InterfaceVersion = 1;

        public KdeOutputDeviceModeV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}