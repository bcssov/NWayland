using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.PlasmaShell
{
    /// <summary>
    /// This interface is used by KF5 powered Wayland shells to communicate withthe compositor and can only be bound one time.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdePlasmaShell : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaShell()
        {
            NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaShell.WlInterface = new WlInterface("org_kde_plasma_shell", 8, new WlMessage[] {
                new WlMessage("get_surface", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaShell.WlInterface);
        }

        /// <summary>
        /// Create a shell surface for an existing surface.<br/><br/>
        /// Only one shell surface can be associated with a givensurface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface GetSurface(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaShell>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaShell.WlInterface);
            }

            public OrgKdePlasmaShell Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaShell(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaShell> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_shell";
        public const int InterfaceVersion = 8;

        public OrgKdePlasmaShell(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An interface that may be implemented by a wl_surface, forimplementations that provide the shell user interface.<br/><br/>
    /// It provides requests to set surface roles, assign an outputor set the position in output coordinates.<br/><br/>
    /// On the server side the object is automatically destroyed whenthe related wl_surface is destroyed.  On client side,org_kde_plasma_surface.destroy() must be called beforedestroying the wl_surface object.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdePlasmaSurface : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdePlasmaSurface()
        {
            NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface.WlInterface = new WlInterface("org_kde_plasma_surface", 8, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_output", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("set_position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("set_role", "u", new WlInterface*[] { null }),
                new WlMessage("set_panel_behavior", "u", new WlInterface*[] { null }),
                new WlMessage("set_skip_taskbar", "2u", new WlInterface*[] { null }),
                new WlMessage("panel_auto_hide_hide", "4", new WlInterface*[] { }),
                new WlMessage("panel_auto_hide_show", "4", new WlInterface*[] { }),
                new WlMessage("set_panel_takes_focus", "4u", new WlInterface*[] { null }),
                new WlMessage("set_skip_switcher", "5u", new WlInterface*[] { null }),
                new WlMessage("open_under_cursor", "7", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("auto_hidden_panel_hidden", "4", new WlInterface*[] { }),
                new WlMessage("auto_hidden_panel_shown", "4", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Assign an output to this shell surface.The compositor will use this information to set the positionwhen org_kde_plasma_surface.set_position request iscalled.<br/><br/>
        /// </summary>
        public void SetOutput(NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Move the surface to new coordinates.<br/><br/>
        /// Coordinates are global, for example 50,50 for a 1920,0+1920x1080 outputis 1970,50 in global coordinates space.<br/><br/>
        /// Use org_kde_plasma_surface.set_output to assign an outputto this surface.<br/><br/>
        /// </summary>
        public void SetPosition(int @x, int @y)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Assign a role to a shell surface.<br/><br/>
        /// The compositor handles surfaces depending on their role.See the explanation below.<br/><br/>
        /// This request fails if the surface already has a role, this meansthe surface role may be assigned only once.<br/><br/>
        /// == Surfaces with splash role ==<br/><br/>
        /// Splash surfaces are placed above every other surface during theshell startup phase.<br/><br/>
        /// The surfaces are placed according to the output coordinates.No size is imposed to those surfaces, the shell has to resizethem according to output size.<br/><br/>
        /// These surfaces are meant to hide the desktop during the startupphase so that the user will always see a ready to work desktop.<br/><br/>
        /// A shell might not create splash surfaces if the compositor revealsthe desktop in an alternative fashion, for example with a fadein effect.<br/><br/>
        /// That depends on how much time the desktop usually need to preparethe workspace or specific design decisions.This specification doesn't impose any particular design.<br/><br/>
        /// When the startup phase is finished, the shell will send theorg_kde_plasma.desktop_ready request to the compositor.<br/><br/>
        /// == Surfaces with desktop role ==<br/><br/>
        /// Desktop surfaces are placed below all other surfaces and are usedto show the actual desktop view with icons, search results orcontrols the user will interact with. What to show depends on theshell implementation.<br/><br/>
        /// The surfaces are placed according to the output coordinates.No size is imposed to those surfaces, the shell has to resizethem according to output size.<br/><br/>
        /// Only one surface per output can have the desktop role.<br/><br/>
        /// == Surfaces with dashboard role ==<br/><br/>
        /// Dashboard surfaces are placed above desktop surfaces and are used toshow additional widgets and controls.<br/><br/>
        /// The surfaces are placed according to the output coordinates.No size is imposed to those surfaces, the shell has to resizethem according to output size.<br/><br/>
        /// Only one surface per output can have the dashboard role.<br/><br/>
        /// == Surfaces with config role ==<br/><br/>
        /// A configuration surface is shown when the user wants to configurepanel or desktop views.<br/><br/>
        /// Only one surface per output can have the config role.<br/><br/>
        /// TODO: This should grab the input like popup menus, right?<br/><br/>
        /// == Surfaces with overlay role ==<br/><br/>
        /// Overlays are special surfaces that shows for a limited amountof time.  Such surfaces are useful to display things like volume,brightness and status changes.<br/><br/>
        /// Compositors may decide to show those surfaces in a layer aboveall surfaces, even full screen ones if so is desired.<br/><br/>
        /// == Surfaces with notification role ==<br/><br/>
        /// Notification surfaces display informative content for a limitedamount of time.  The compositor may decide to show them in a cornerdepending on the configuration.<br/><br/>
        /// These surfaces are shown in a layer above all other surfaces exceptfor full screen ones.<br/><br/>
        /// == Surfaces with lock role ==<br/><br/>
        /// The lock surface is shown by the compositor when the session islocked, users interact with it to unlock the session.<br/><br/>
        /// Compositors should move lock surfaces to 0,0 in outputcoordinates space and hide all other surfaces for security sake.For the same reason it is recommended that clients make thelock surface as big as the screen.<br/><br/>
        /// Only one surface per output can have the lock role.<br/><br/>
        /// </summary>
        public void SetRole(uint @role)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @role
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Set flags bitmask as described by the flag enum.Pass 0 to unset any flag, the surface will adjust its behavior tothe default.<br/><br/>
        /// </summary>
        public void SetPanelBehavior(uint @flag)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @flag
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Setting this bit to the window, will make it say it prefers to not be listed in the taskbar. Taskbar implementations may or may not follow this hint.<br/><br/>
        /// </summary>
        public void SetSkipTaskbar(uint @skip)
        {
            if (Version < 2)
                throw new InvalidOperationException("Request set_skip_taskbar is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                @skip
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// A panel surface with panel_behavior auto_hide can perform this request to hide the panelon a screen edge without unmapping it. The compositor informs the client about the panelbeing hidden with the event auto_hidden_panel_hidden.<br/><br/>
        /// The compositor will restore the visibility state of thesurface when the pointer touches the screen edge the panel borders. Once the compositor restoresthe visibility the event auto_hidden_panel_shown will be sent. This event will also be sentif the compositor is unable to hide the panel.<br/><br/>
        /// The client can also request to show the panel again with the request panel_auto_hide_show.<br/><br/>
        /// </summary>
        public void PanelAutoHideHide()
        {
            if (Version < 4)
                throw new InvalidOperationException("Request panel_auto_hide_hide is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        /// <summary>
        /// A panel surface with panel_behavior auto_hide can perform this request to show the panelagain which got hidden with panel_auto_hide_hide.<br/><br/>
        /// </summary>
        public void PanelAutoHideShow()
        {
            if (Version < 4)
                throw new InvalidOperationException("Request panel_auto_hide_show is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        /// <summary>
        /// By default various org_kde_plasma_surface roles do not take focus and cannot beactivated. With this request the compositor can be instructed to pass focus also to thisorg_kde_plasma_surface.<br/><br/>
        /// </summary>
        public void SetPanelTakesFocus(uint @takesFocus)
        {
            if (Version < 4)
                throw new InvalidOperationException("Request set_panel_takes_focus is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                @takesFocus
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// Setting this bit will indicate that the window prefers not to be listed in a switcher.<br/><br/>
        /// </summary>
        public void SetSkipSwitcher(uint @skip)
        {
            if (Version < 5)
                throw new InvalidOperationException("Request set_skip_switcher is only supported since version 5");
            WlArgument* __args = stackalloc WlArgument[] {
                @skip
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        /// <summary>
        /// Request the initial position of this surface to be under the currentcursor position. Has to be called before attaching any buffer to this surface.<br/><br/>
        /// </summary>
        public void OpenUnderCursor()
        {
            if (Version < 7)
                throw new InvalidOperationException("Request open_under_cursor is only supported since version 7");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// An auto-hiding panel got hidden by the compositor.<br/><br/>
            /// </summary>
            void OnAutoHiddenPanelHidden(NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface eventSender);

            /// <summary>
            /// An auto-hiding panel got shown by the compositor.<br/><br/>
            /// </summary>
            void OnAutoHiddenPanelShown(NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnAutoHiddenPanelHidden(this);
                    break;
                case 1:
                    Events?.OnAutoHiddenPanelShown(this);
                    break;
            }
        }

        public enum RoleEnum
        {
            Normal = 0,
            Desktop = 1,
            Panel = 2,
            Onscreendisplay = 3,
            Notification = 4,
            Tooltip = 5,
            Criticalnotification = 6,
            Appletpopup = 7
        }

        public enum PanelBehaviorEnum
        {
            AlwaysVisible = 1,
            AutoHide = 2,
            WindowsCanCover = 3,
            WindowsGoBelow = 4
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// Request panel_auto_hide performed on a surface which does not correspond to an auto-hide panel.<br/><br/>
            /// </summary>
            PanelNotAutoHide = 0
        }

        private class ProxyFactory : IBindFactory<OrgKdePlasmaSurface>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.PlasmaShell.OrgKdePlasmaSurface.WlInterface);
            }

            public OrgKdePlasmaSurface Create(IntPtr handle, int version)
            {
                return new OrgKdePlasmaSurface(handle, version);
            }
        }

        public static IBindFactory<OrgKdePlasmaSurface> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_plasma_surface";
        public const int InterfaceVersion = 8;

        public OrgKdePlasmaSurface(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}