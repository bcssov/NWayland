using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.KdeOutputManagementV2
{
    /// <summary>
    /// This interface enables clients to set properties of output devices for screenconfiguration purposes via the server. To this end output devices are referencedby global kde_output_device_v2 objects.<br/><br/>
    /// outputmanagement (wl_global)--------------------------request:* create_configuration -&gt; outputconfiguration (wl_resource)<br/><br/>
    /// outputconfiguration (wl_resource)--------------------------requests:* enable(outputdevice, bool)* mode(outputdevice, mode)* transformation(outputdevice, flag)* position(outputdevice, x, y)* apply<br/><br/>
    /// events:* applied* failed<br/><br/>
    /// The server registers one outputmanagement object as a global object. In orderto configure outputs a client requests create_configuration, which provides aresource referencing an outputconfiguration for one-time configuration. Thatway the server knows which requests belong together and can group them by that.<br/><br/>
    /// On the outputconfiguration object the client calls for each output whether theoutput should be enabled, which mode should be set (by referencing the mode fromthe list of announced modes) and the output's global position. Once all outputsare configured that way, the client calls apply.At that point and not earlier the server should try to apply the configuration.If this succeeds the server emits the applied signal, otherwise the failedsignal, such that the configuring client is noticed about the success of itsconfiguration request.<br/><br/>
    /// Through this design the interface enables atomic output configuration changes ifinternally supported by the server.<br/><br/>
    /// <br/><br/>
    /// </summary>
    public sealed unsafe partial class KdeOutputManagementV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static KdeOutputManagementV2()
        {
            NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputManagementV2.WlInterface = new WlInterface("kde_output_management_v2", 2, new WlMessage[] {
                new WlMessage("create_configuration", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputManagementV2.WlInterface);
        }

        /// <summary>
        /// Request an outputconfiguration object through which the client can configureoutput devices.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2 CreateConfiguration()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<KdeOutputManagementV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputManagementV2.WlInterface);
            }

            public KdeOutputManagementV2 Create(IntPtr handle, int version)
            {
                return new KdeOutputManagementV2(handle, version);
            }
        }

        public static IBindFactory<KdeOutputManagementV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "kde_output_management_v2";
        public const int InterfaceVersion = 2;

        public KdeOutputManagementV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// outputconfiguration is a client-specific resource that can be used to askthe server to apply changes to available output devices.<br/><br/>
    /// The client receives a list of output devices from the registry. When it wantsto apply new settings, it creates a configuration object from theoutputmanagement global, writes changes through this object's enable, scale,transform and mode calls. It then asks the server to apply these settings inan atomic fashion, for example through Linux' DRM interface.<br/><br/>
    /// The server signals back whether the new settings have applied successfullyor failed to apply. outputdevice objects are updated after the changes have beenapplied to the hardware and before the server side sends the applied event.<br/><br/>
    /// </summary>
    public sealed unsafe partial class KdeOutputConfigurationV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static KdeOutputConfigurationV2()
        {
            NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2.WlInterface = new WlInterface("kde_output_configuration_v2", 2, new WlMessage[] {
                new WlMessage("enable", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("mode", "oo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2.WlInterface) }),
                new WlMessage("transform", "oi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("position", "oii", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null, null }),
                new WlMessage("scale", "of", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("apply", "", new WlInterface*[] { }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("overscan", "ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("set_vrr_policy", "ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("set_rgb_range", "ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface), null }),
                new WlMessage("set_primary_output", "2o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("applied", "", new WlInterface*[] { }),
                new WlMessage("failed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2.WlInterface);
        }

        /// <summary>
        /// Mark the output as enabled or disabled.<br/><br/>
        /// </summary>
        public void Enable(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, int @enable)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @enable
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Sets the mode for a given output.<br/><br/>
        /// </summary>
        public void Mode(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceModeV2 @mode)
        {
            if (@mode == null)
                throw new ArgumentNullException("mode");
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @mode
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Sets the transformation for a given output.<br/><br/>
        /// </summary>
        public void Transform(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, int @transform)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @transform
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Sets the position for this output device. (x,y) describe the top-left cornerof the output in global space, whereby the origin (0,0) of the global spacehas to be aligned with the top-left corner of the most left and in case thisdoes not define a single one the top output.<br/><br/>
        /// There may be no gaps or overlaps between outputs, i.e. the outputs arestacked horizontally, vertically, or both on each other.<br/><br/>
        /// </summary>
        public void Position(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, int @x, int @y)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Sets the scaling factor for this output device.<br/><br/>
        /// </summary>
        public void Scale(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, WlFixed @scale)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @scale
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Asks the server to apply property changes requested through this outputconfigurationobject to all outputs on the server side.<br/><br/>
        /// The output configuration can be applied only once. The already_applied protocol errorwill be posted if the apply request is called the second time.<br/><br/>
        /// </summary>
        public void Apply()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Set the overscan value of this output device with a value in percent.<br/><br/>
        /// </summary>
        public void Overscan(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, uint @overscan)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                @overscan
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        /// <summary>
        /// Set what policy the compositor should employ regarding its use ofvariable refresh rate.<br/><br/>
        /// </summary>
        public void SetVrrPolicy(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, VrrPolicyEnum @policy)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                (uint)@policy
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// Whether full or limited color range should be used<br/><br/>
        /// </summary>
        public void SetRgbRange(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @outputdevice, RgbRangeEnum @rgbRange)
        {
            if (@outputdevice == null)
                throw new ArgumentNullException("outputdevice");
            WlArgument* __args = stackalloc WlArgument[] {
                @outputdevice,
                (uint)@rgbRange
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        public void SetPrimaryOutput(NWayland.Protocols.Plasma.KdeOutputDeviceV2.KdeOutputDeviceV2 @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            if (Version < 2)
                throw new InvalidOperationException("Request set_primary_output is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent after the server has successfully applied the changes..<br/><br/>
            /// </summary>
            void OnApplied(NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2 eventSender);

            /// <summary>
            /// Sent if the server rejects the changes or failed to apply them.<br/><br/>
            /// </summary>
            void OnFailed(NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnApplied(this);
                    break;
                case 1:
                    Events?.OnFailed(this);
                    break;
            }
        }

        /// <summary>
        /// These error can be emitted in response to kde_output_configuration_v2 requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// the config is already applied<br/><br/>
            /// </summary>
            AlreadyApplied = 0
        }

        /// <summary>
        /// Describes when the compositor may employ variable refresh rate<br/><br/>
        /// </summary>
        public enum VrrPolicyEnum
        {
            Never = 0,
            Always = 1,
            Automatic = 2
        }

        /// <summary>
        /// Whether this output should use full or limited rgb.<br/><br/>
        /// </summary>
        public enum RgbRangeEnum
        {
            Automatic = 0,
            Full = 1,
            Limited = 2
        }

        private class ProxyFactory : IBindFactory<KdeOutputConfigurationV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.KdeOutputManagementV2.KdeOutputConfigurationV2.WlInterface);
            }

            public KdeOutputConfigurationV2 Create(IntPtr handle, int version)
            {
                return new KdeOutputConfigurationV2(handle, version);
            }
        }

        public static IBindFactory<KdeOutputConfigurationV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "kde_output_configuration_v2";
        public const int InterfaceVersion = 2;

        public KdeOutputConfigurationV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}