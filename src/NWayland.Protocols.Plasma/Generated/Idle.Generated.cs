using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.Idle
{
    /// <summary>
    /// This interface allows to monitor user idle time on a given seat. The interfaceallows to register timers which trigger after no user activity was registeredon the seat for a given interval. It notifies when user activity resumes.<br/><br/>
    /// This is useful for applications wanting to perform actions when the user is notinteracting with the system, e.g. chat applications setting the user as away, powermanagement features to dim screen, etc..<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinIdle : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinIdle()
        {
            NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdle.WlInterface = new WlInterface("org_kde_kwin_idle", 1, new WlMessage[] {
                new WlMessage("get_idle_timeout", "nou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface), null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdle.WlInterface);
        }

        public NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout GetIdleTimeout(NWayland.Protocols.Wayland.WlSeat @seat, uint @timeout)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @seat,
                @timeout
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinIdle>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdle.WlInterface);
            }

            public OrgKdeKwinIdle Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinIdle(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinIdle> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_idle";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinIdle(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    public sealed unsafe partial class OrgKdeKwinIdleTimeout : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinIdleTimeout()
        {
            NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout.WlInterface = new WlInterface("org_kde_kwin_idle_timeout", 1, new WlMessage[] {
                new WlMessage("release", "", new WlInterface*[] { }),
                new WlMessage("simulate_user_activity", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("idle", "", new WlInterface*[] { }),
                new WlMessage("resumed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public void SimulateUserActivity()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        public interface IEvents
        {
            void OnIdle(NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout eventSender);
            void OnResumed(NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnIdle(this);
                    break;
                case 1:
                    Events?.OnResumed(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinIdleTimeout>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.Idle.OrgKdeKwinIdleTimeout.WlInterface);
            }

            public OrgKdeKwinIdleTimeout Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinIdleTimeout(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinIdleTimeout> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_idle_timeout";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinIdleTimeout(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}