using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Plasma.ServerDecoration
{
    /// <summary>
    /// This interface allows to coordinate whether the server should createa server-side window decoration around a wl_surface representing ashell surface (wl_shell_surface or similar). By announcing supportfor this interface the server indicates that it supports serverside decorations.<br/><br/>
    /// Use in conjunction with zxdg_decoration_manager_v1 is undefined.<br/><br/>
    /// </summary>
    public sealed unsafe partial class OrgKdeKwinServerDecorationManager : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinServerDecorationManager()
        {
            NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecorationManager.WlInterface = new WlInterface("org_kde_kwin_server_decoration_manager", 1, new WlMessage[] {
                new WlMessage("create", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("default_mode", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecorationManager.WlInterface);
        }

        /// <summary>
        /// When a client creates a server-side decoration object it indicatesthat it supports the protocol. The client is supposed to tell theserver whether it wants server-side decorations or will provideclient-side decorations.<br/><br/>
        /// If the client does not create a server-side decoration object fora surface the server interprets this as lack of support for thisprotocol and considers it as client-side decorated. Nevertheless aclient-side decorated surface should use this protocol to indicateto the server that it does not want a server-side deco.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration Create(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is emitted directly after binding the interface. It containsthe default mode for the decoration. When a new server decoration objectis created this new object will be in the default mode until the firstrequest_mode is requested.<br/><br/>
            /// The server may change the default mode at any time.<br/><br/>
            /// </summary>
            void OnDefaultMode(NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecorationManager eventSender, uint @mode);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnDefaultMode(this, arguments[0].UInt32);
                    break;
            }
        }

        public enum ModeEnum
        {
            /// <summary>
            /// Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated.<br/><br/>
            /// </summary>
            None = 0,
            /// <summary>
            /// Client-side decoration: The decoration is part of the surface and the client.<br/><br/>
            /// </summary>
            Client = 1,
            /// <summary>
            /// Server-side decoration: The server embeds the surface into a decoration frame.<br/><br/>
            /// </summary>
            Server = 2
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinServerDecorationManager>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecorationManager.WlInterface);
            }

            public OrgKdeKwinServerDecorationManager Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinServerDecorationManager(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinServerDecorationManager> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_server_decoration_manager";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinServerDecorationManager(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    public sealed unsafe partial class OrgKdeKwinServerDecoration : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static OrgKdeKwinServerDecoration()
        {
            NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration.WlInterface = new WlInterface("org_kde_kwin_server_decoration", 1, new WlMessage[] {
                new WlMessage("release", "", new WlInterface*[] { }),
                new WlMessage("request_mode", "u", new WlInterface*[] { null })
            }, new WlMessage[] {
                new WlMessage("mode", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public void RequestMode(uint @mode)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @mode
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is emitted directly after the decoration is created andrepresents the base decoration policy by the server. E.g. a serverwhich wants all surfaces to be client-side decorated will send Client,a server which wants server-side decoration will send Server.<br/><br/>
            /// The client can request a different mode through the decoration request.The server will acknowledge this by another event with the same mode. Soeven if a server prefers server-side decoration it's possible to force aclient-side decoration.<br/><br/>
            /// The server may emit this event at any time. In this case the client canagain request a different mode. It's the responsibility of the server toprevent a feedback loop.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration eventSender, uint @mode);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnMode(this, arguments[0].UInt32);
                    break;
            }
        }

        public enum ModeEnum
        {
            /// <summary>
            /// Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated.<br/><br/>
            /// </summary>
            None = 0,
            /// <summary>
            /// Client-side decoration: The decoration is part of the surface and the client.<br/><br/>
            /// </summary>
            Client = 1,
            /// <summary>
            /// Server-side decoration: The server embeds the surface into a decoration frame.<br/><br/>
            /// </summary>
            Server = 2
        }

        private class ProxyFactory : IBindFactory<OrgKdeKwinServerDecoration>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Plasma.ServerDecoration.OrgKdeKwinServerDecoration.WlInterface);
            }

            public OrgKdeKwinServerDecoration Create(IntPtr handle, int version)
            {
                return new OrgKdeKwinServerDecoration(handle, version);
            }
        }

        public static IBindFactory<OrgKdeKwinServerDecoration> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "org_kde_kwin_server_decoration";
        public const int InterfaceVersion = 1;

        public OrgKdeKwinServerDecoration(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}