using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.LinuxDmabufUnstableV1
{
    /// <summary>
    /// Following the interfaces from:
    /// https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
    /// https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
    /// and the Linux DRM sub-system's AddFb2 ioctl.
    /// <br/>
    /// <br/>
    /// This interface offers ways to create generic dmabuf-based wl_buffers.
    /// <br/>
    /// <br/>
    /// Clients can use the get_surface_feedback request to get dmabuf feedback
    /// for a particular surface. If the client wants to retrieve feedback not
    /// tied to a surface, they can use the get_default_feedback request.
    /// <br/>
    /// <br/>
    /// The following are required from clients:
    /// <br/>
    /// <br/>
    /// - Clients must ensure that either all data in the dma-buf is
    /// coherent for all subsequent read access or that coherency is
    /// correctly handled by the underlying kernel-side dma-buf
    /// implementation.
    /// <br/>
    /// <br/>
    /// - Don't make any more attachments after sending the buffer to the
    /// compositor. Making more attachments later increases the risk of
    /// the compositor not being able to use (re-import) an existing
    /// dmabuf-based wl_buffer.
    /// <br/>
    /// <br/>
    /// The underlying graphics stack must ensure the following:
    /// <br/>
    /// <br/>
    /// - The dmabuf file descriptors relayed to the server will stay valid
    /// for the whole lifetime of the wl_buffer. This means the server may
    /// at any time use those fds to import the dmabuf into any kernel
    /// sub-system that might accept it.
    /// <br/>
    /// <br/>
    /// However, when the underlying graphics stack fails to deliver the
    /// promise, because of e.g. a device hot-unplug which raises internal
    /// errors, after the wl_buffer has been successfully created the
    /// compositor must not raise protocol errors to the client when dmabuf
    /// import later fails.
    /// <br/>
    /// <br/>
    /// To create a wl_buffer from one or more dmabufs, a client creates a
    /// zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
    /// request. All planes required by the intended format are added with
    /// the 'add' request. Finally, a 'create' or 'create_immed' request is
    /// issued, which has the following outcome depending on the import success.
    /// <br/>
    /// <br/>
    /// The 'create' request,
    /// - on success, triggers a 'created' event which provides the final
    /// wl_buffer to the client.
    /// - on failure, triggers a 'failed' event to convey that the server
    /// cannot use the dmabufs received from the client.
    /// <br/>
    /// <br/>
    /// For the 'create_immed' request,
    /// - on success, the server immediately imports the added dmabufs to
    /// create a wl_buffer. No event is sent from the server in this case.
    /// - on failure, the server can choose to either:
    /// - terminate the client by raising a fatal error.
    /// - mark the wl_buffer as failed, and send a 'failed' event to the
    /// client. If the client uses a failed wl_buffer as an argument to any
    /// request, the behaviour is compositor implementation-defined.
    /// <br/>
    /// <br/>
    /// For all DRM formats and unless specified in another protocol extension,
    /// pre-multiplied alpha is used for pixel values.
    /// <br/>
    /// <br/>
    /// Warning! The protocol described in this file is experimental and
    /// backward incompatible changes may be made. Backward compatible changes
    /// may be added together with the corresponding interface version bump.
    /// Backward incompatible changes are done by bumping the version number in
    /// the protocol and interface names and resetting the interface version.
    /// Once the protocol is to be declared stable, the 'z' prefix and the
    /// version number in the protocol and interface names are removed and the
    /// interface version number is reset.
    /// </summary>
    public sealed unsafe partial class ZwpLinuxDmabufV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxDmabufV1()
        {
            NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufV1.WlInterface = new WlInterface("zwp_linux_dmabuf_v1", 4, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("create_params", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1.WlInterface) }),
                new WlMessage("get_default_feedback", "4n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface) }),
                new WlMessage("get_surface_feedback", "4no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("format", "u", new WlInterface*[] { null }),
                new WlMessage("modifier", "3uuu", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// This temporary object is used to collect multiple dmabuf handles into
        /// a single batch to create a wl_buffer. It can only be used once and
        /// should be destroyed after a 'created' or 'failed' event has been
        /// received.
        /// </summary>
        public NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1 CreateParams()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1(__ret, Version);
        }

        /// <summary>
        /// This request creates a new wp_linux_dmabuf_feedback object not bound
        /// to a particular surface. This object will deliver feedback about dmabuf
        /// parameters to use if the client doesn't support per-surface feedback
        /// (see get_surface_feedback).
        /// </summary>
        public NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 GetDefaultFeedback()
        {
            if (Version < 4)
                throw new InvalidOperationException("Request get_default_feedback is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 2, __args, ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1(__ret, Version);
        }

        /// <summary>
        /// This request creates a new wp_linux_dmabuf_feedback object for the
        /// specified wl_surface. This object will deliver feedback about dmabuf
        /// parameters to use for buffers attached to this surface.
        /// <br/>
        /// <br/>
        /// If the surface is destroyed before the wp_linux_dmabuf_feedback object,
        /// the feedback object becomes inert.
        /// </summary>
        public NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 GetSurfaceFeedback(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            if (Version < 4)
                throw new InvalidOperationException("Request get_surface_feedback is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 3, __args, ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event advertises one buffer format that the server supports.
            /// All the supported formats are advertised once when the client
            /// binds to this interface. A roundtrip after binding guarantees
            /// that the client has received all supported formats.
            /// <br/>
            /// <br/>
            /// For the definition of the format codes, see the
            /// zwp_linux_buffer_params_v1::create request.
            /// <br/>
            /// <br/>
            /// Starting version 4, the format event is deprecated and must not be
            /// sent by compositors. Instead, use get_default_feedback or
            /// get_surface_feedback.
            /// </summary>
            void OnFormat(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufV1 eventSender, uint @format);

            /// <summary>
            /// This event advertises the formats that the server supports, along with
            /// the modifiers supported for each format. All the supported modifiers
            /// for all the supported formats are advertised once when the client
            /// binds to this interface. A roundtrip after binding guarantees that
            /// the client has received all supported format-modifier pairs.
            /// <br/>
            /// <br/>
            /// For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
            /// 0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
            /// It indicates that the server can support the format with an implicit
            /// modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
            /// is as if no explicit modifier is specified. The effective modifier
            /// will be derived from the dmabuf.
            /// <br/>
            /// <br/>
            /// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
            /// a given format supports both explicit modifiers and implicit modifiers.
            /// <br/>
            /// <br/>
            /// For the definition of the format and modifier codes, see the
            /// zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
            /// requests.
            /// <br/>
            /// <br/>
            /// Starting version 4, the modifier event is deprecated and must not be
            /// sent by compositors. Instead, use get_default_feedback or
            /// get_surface_feedback.
            /// </summary>
            void OnModifier(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufV1 eventSender, uint @format, uint @modifierHi, uint @modifierLo);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnFormat(this, arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnModifier(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxDmabufV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufV1.WlInterface);
            }

            public ZwpLinuxDmabufV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxDmabufV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxDmabufV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_dmabuf_v1";
        public const int InterfaceVersion = 4;

        public ZwpLinuxDmabufV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This temporary object is a collection of dmabufs and other
    /// parameters that together form a single logical buffer. The temporary
    /// object may eventually create one wl_buffer unless cancelled by
    /// destroying it before requesting 'create'.
    /// <br/>
    /// <br/>
    /// Single-planar formats only require one dmabuf, however
    /// multi-planar formats may require more than one dmabuf. For all
    /// formats, an 'add' request must be called once per plane (even if the
    /// underlying dmabuf fd is identical).
    /// <br/>
    /// <br/>
    /// You must use consecutive plane indices ('plane_idx' argument for 'add')
    /// from zero to the number of planes used by the drm_fourcc format code.
    /// All planes required by the format must be given exactly once, but can
    /// be given in any order. Each plane index can be set only once.
    /// </summary>
    public sealed unsafe partial class ZwpLinuxBufferParamsV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxBufferParamsV1()
        {
            NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1.WlInterface = new WlInterface("zwp_linux_buffer_params_v1", 4, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("add", "huuuuu", new WlInterface*[] { null, null, null, null, null, null }),
                new WlMessage("create", "iiuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("create_immed", "2niiuu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface), null, null, null, null })
            }, new WlMessage[] {
                new WlMessage("created", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface) }),
                new WlMessage("failed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// This request adds one dmabuf to the set in this
        /// zwp_linux_buffer_params_v1.
        /// <br/>
        /// <br/>
        /// The 64-bit unsigned value combined from modifier_hi and modifier_lo
        /// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
        /// fb modifier, which is defined in drm_mode.h of Linux UAPI.
        /// This is an opaque token. Drivers use this token to express tiling,
        /// compression, etc. driver-specific modifications to the base format
        /// defined by the DRM fourcc code.
        /// <br/>
        /// <br/>
        /// Starting from version 4, the invalid_format protocol error is sent if
        /// the format + modifier pair was not advertised as supported.
        /// <br/>
        /// <br/>
        /// This request raises the PLANE_IDX error if plane_idx is too large.
        /// The error PLANE_SET is raised if attempting to set a plane that
        /// was already set.
        /// </summary>
        public void Add(int @fd, uint @planeIdx, uint @offset, uint @stride, uint @modifierHi, uint @modifierLo)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @fd,
                @planeIdx,
                @offset,
                @stride,
                @modifierHi,
                @modifierLo
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// This asks for creation of a wl_buffer from the added dmabuf
        /// buffers. The wl_buffer is not created immediately but returned via
        /// the 'created' event if the dmabuf sharing succeeds. The sharing
        /// may fail at runtime for reasons a client cannot predict, in
        /// which case the 'failed' event is triggered.
        /// <br/>
        /// <br/>
        /// The 'format' argument is a DRM_FORMAT code, as defined by the
        /// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
        /// authoritative source on how the format codes should work.
        /// <br/>
        /// <br/>
        /// The 'flags' is a bitfield of the flags defined in enum "flags".
        /// 'y_invert' means the that the image needs to be y-flipped.
        /// <br/>
        /// <br/>
        /// Flag 'interlaced' means that the frame in the buffer is not
        /// progressive as usual, but interlaced. An interlaced buffer as
        /// supported here must always contain both top and bottom fields.
        /// The top field always begins on the first pixel row. The temporal
        /// ordering between the two fields is top field first, unless
        /// 'bottom_first' is specified. It is undefined whether 'bottom_first'
        /// is ignored if 'interlaced' is not set.
        /// <br/>
        /// <br/>
        /// This protocol does not convey any information about field rate,
        /// duration, or timing, other than the relative ordering between the
        /// two fields in one buffer. A compositor may have to estimate the
        /// intended field rate from the incoming buffer rate. It is undefined
        /// whether the time of receiving wl_surface.commit with a new buffer
        /// attached, applying the wl_surface state, wl_surface.frame callback
        /// trigger, presentation, or any other point in the compositor cycle
        /// is used to measure the frame or field times. There is no support
        /// for detecting missed or late frames/fields/buffers either, and
        /// there is no support whatsoever for cooperating with interlaced
        /// compositor output.
        /// <br/>
        /// <br/>
        /// The composited image quality resulting from the use of interlaced
        /// buffers is explicitly undefined. A compositor may use elaborate
        /// hardware features or software to deinterlace and create progressive
        /// output frames from a sequence of interlaced input buffers, or it
        /// may produce substandard image quality. However, compositors that
        /// cannot guarantee reasonable image quality in all cases are recommended
        /// to just reject all interlaced buffers.
        /// <br/>
        /// <br/>
        /// Any argument errors, including non-positive width or height,
        /// mismatch between the number of planes and the format, bad
        /// format, bad offset or stride, may be indicated by fatal protocol
        /// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
        /// OUT_OF_BOUNDS.
        /// <br/>
        /// <br/>
        /// Dmabuf import errors in the server that are not obvious client
        /// bugs are returned via the 'failed' event as non-fatal. This
        /// allows attempting dmabuf sharing and falling back in the client
        /// if it fails.
        /// <br/>
        /// <br/>
        /// This request can be sent only once in the object's lifetime, after
        /// which the only legal request is destroy. This object should be
        /// destroyed after issuing a 'create' request. Attempting to use this
        /// object after issuing 'create' raises ALREADY_USED protocol error.
        /// <br/>
        /// <br/>
        /// It is not mandatory to issue 'create'. If a client wants to
        /// cancel the buffer creation, it can just destroy this object.
        /// </summary>
        public void Create(int @width, int @height, uint @format, FlagsEnum @flags)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @width,
                @height,
                @format,
                (uint)@flags
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// This asks for immediate creation of a wl_buffer by importing the
        /// added dmabufs.
        /// <br/>
        /// <br/>
        /// In case of import success, no event is sent from the server, and the
        /// wl_buffer is ready to be used by the client.
        /// <br/>
        /// <br/>
        /// Upon import failure, either of the following may happen, as seen fit
        /// by the implementation:
        /// - the client is terminated with one of the following fatal protocol
        /// errors:
        /// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
        /// in case of argument errors such as mismatch between the number
        /// of planes and the format, bad format, non-positive width or
        /// height, or bad offset or stride.
        /// - INVALID_WL_BUFFER, in case the cause for failure is unknown or
        /// plaform specific.
        /// - the server creates an invalid wl_buffer, marks it as failed and
        /// sends a 'failed' event to the client. The result of using this
        /// invalid wl_buffer as an argument in any request by the client is
        /// defined by the compositor implementation.
        /// <br/>
        /// <br/>
        /// This takes the same arguments as a 'create' request, and obeys the
        /// same restrictions.
        /// </summary>
        public NWayland.Protocols.Wayland.WlBuffer CreateImmed(int @width, int @height, uint @format, FlagsEnum @flags)
        {
            if (Version < 2)
                throw new InvalidOperationException("Request create_immed is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @width,
                @height,
                @format,
                (uint)@flags
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 3, __args, ref NWayland.Protocols.Wayland.WlBuffer.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlBuffer(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event indicates that the attempted buffer creation was
            /// successful. It provides the new wl_buffer referencing the dmabuf(s).
            /// <br/>
            /// <br/>
            /// Upon receiving this event, the client should destroy the
            /// zlinux_dmabuf_params object.
            /// </summary>
            void OnCreated(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1 eventSender, WlBuffer @buffer);

            /// <summary>
            /// This event indicates that the attempted buffer creation has
            /// failed. It usually means that one of the dmabuf constraints
            /// has not been fulfilled.
            /// <br/>
            /// <br/>
            /// Upon receiving this event, the client should destroy the
            /// zlinux_buffer_params object.
            /// </summary>
            void OnFailed(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnCreated(this, new WlBuffer(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnFailed(this);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary></summary>
            AlreadyUsed = 0,
            /// <summary></summary>
            PlaneIdx = 1,
            /// <summary></summary>
            PlaneSet = 2,
            /// <summary></summary>
            Incomplete = 3,
            /// <summary></summary>
            InvalidFormat = 4,
            /// <summary></summary>
            InvalidDimensions = 5,
            /// <summary></summary>
            OutOfBounds = 6,
            /// <summary></summary>
            InvalidWlBuffer = 7
        }

        [Flags]
        public enum FlagsEnum
        {
            /// <summary></summary>
            YInvert = 1,
            /// <summary></summary>
            Interlaced = 2,
            /// <summary></summary>
            BottomFirst = 4
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxBufferParamsV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxBufferParamsV1.WlInterface);
            }

            public ZwpLinuxBufferParamsV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxBufferParamsV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxBufferParamsV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_buffer_params_v1";
        public const int InterfaceVersion = 4;

        public ZwpLinuxBufferParamsV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object advertises dmabuf parameters feedback. This includes the
    /// preferred devices and the supported formats/modifiers.
    /// <br/>
    /// <br/>
    /// The parameters are sent once when this object is created and whenever they
    /// change. The done event is always sent once after all parameters have been
    /// sent. When a single parameter changes, all parameters are re-sent by the
    /// compositor.
    /// <br/>
    /// <br/>
    /// Compositors can re-send the parameters when the current client buffer
    /// allocations are sub-optimal. Compositors should not re-send the
    /// parameters if re-allocating the buffers would not result in a more optimal
    /// configuration. In particular, compositors should avoid sending the exact
    /// same parameters multiple times in a row.
    /// <br/>
    /// <br/>
    /// The tranche_target_device and tranche_modifier events are grouped by
    /// tranches of preference. For each tranche, a tranche_target_device, one
    /// tranche_flags and one or more tranche_modifier events are sent, followed
    /// by a tranche_done event finishing the list. The tranches are sent in
    /// descending order of preference. All formats and modifiers in the same
    /// tranche have the same preference.
    /// <br/>
    /// <br/>
    /// To send parameters, the compositor sends one main_device event, tranches
    /// (each consisting of one tranche_target_device event, one tranche_flags
    /// event, tranche_modifier events and then a tranche_done event), then one
    /// done event.
    /// </summary>
    public sealed unsafe partial class ZwpLinuxDmabufFeedbackV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxDmabufFeedbackV1()
        {
            NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface = new WlInterface("zwp_linux_dmabuf_feedback_v1", 4, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("format_table", "hu", new WlInterface*[] { null, null }),
                new WlMessage("main_device", "a", new WlInterface*[] { null }),
                new WlMessage("tranche_done", "", new WlInterface*[] { }),
                new WlMessage("tranche_target_device", "a", new WlInterface*[] { null }),
                new WlMessage("tranche_formats", "a", new WlInterface*[] { null }),
                new WlMessage("tranche_flags", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent after all parameters of a wp_linux_dmabuf_feedback
            /// object have been sent.
            /// <br/>
            /// <br/>
            /// This allows changes to the wp_linux_dmabuf_feedback parameters to be
            /// seen as atomic, even if they happen via multiple events.
            /// </summary>
            void OnDone(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender);

            /// <summary>
            /// This event provides a file descriptor which can be memory-mapped to
            /// access the format and modifier table.
            /// <br/>
            /// <br/>
            /// The table contains a tightly packed array of consecutive format +
            /// modifier pairs. Each pair is 16 bytes wide. It contains a format as a
            /// 32-bit unsigned integer, followed by 4 bytes of unused padding, and a
            /// modifier as a 64-bit unsigned integer. The native endianness is used.
            /// <br/>
            /// <br/>
            /// The client must map the file descriptor in read-only private mode.
            /// <br/>
            /// <br/>
            /// Compositors are not allowed to mutate the table file contents once this
            /// event has been sent. Instead, compositors must create a new, separate
            /// table file and re-send feedback parameters. Compositors are allowed to
            /// store duplicate format + modifier pairs in the table.
            /// </summary>
            void OnFormatTable(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender, int @fd, uint @size);

            /// <summary>
            /// This event advertises the main device that the server prefers to use
            /// when direct scan-out to the target device isn't possible. The
            /// advertised main device may be different for each
            /// wp_linux_dmabuf_feedback object, and may change over time.
            /// <br/>
            /// <br/>
            /// There is exactly one main device. The compositor must send at least
            /// one preference tranche with tranche_target_device equal to main_device.
            /// <br/>
            /// <br/>
            /// Clients need to create buffers that the main device can import and
            /// read from, otherwise creating the dmabuf wl_buffer will fail (see the
            /// wp_linux_buffer_params.create and create_immed requests for details).
            /// The main device will also likely be kept active by the compositor,
            /// so clients can use it instead of waking up another device for power
            /// savings.
            /// <br/>
            /// <br/>
            /// In general the device is a DRM node. The DRM node type (primary vs.
            /// render) is unspecified. Clients must not rely on the compositor sending
            /// a particular node type. Clients cannot check two devices for equality
            /// by comparing the dev_t value.
            /// <br/>
            /// <br/>
            /// If explicit modifiers are not supported and the client performs buffer
            /// allocations on a different device than the main device, then the client
            /// must force the buffer to have a linear layout.
            /// </summary>
            void OnMainDevice(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender, ReadOnlySpan<byte> @device);

            /// <summary>
            /// This event splits tranche_target_device and tranche_modifier events in
            /// preference tranches. It is sent after a set of tranche_target_device
            /// and tranche_modifier events; it represents the end of a tranche. The
            /// next tranche will have a lower preference.
            /// </summary>
            void OnTrancheDone(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender);

            /// <summary>
            /// This event advertises the target device that the server prefers to use
            /// for a buffer created given this tranche. The advertised target device
            /// may be different for each preference tranche, and may change over time.
            /// <br/>
            /// <br/>
            /// There is exactly one target device per tranche.
            /// <br/>
            /// <br/>
            /// The target device may be a scan-out device, for example if the
            /// compositor prefers to directly scan-out a buffer created given this
            /// tranche. The target device may be a rendering device, for example if
            /// the compositor prefers to texture from said buffer.
            /// <br/>
            /// <br/>
            /// The client can use this hint to allocate the buffer in a way that makes
            /// it accessible from the target device, ideally directly. The buffer must
            /// still be accessible from the main device, either through direct import
            /// or through a potentially more expensive fallback path. If the buffer
            /// can't be directly imported from the main device then clients must be
            /// prepared for the compositor changing the tranche priority or making
            /// wl_buffer creation fail (see the wp_linux_buffer_params.create and
            /// create_immed requests for details).
            /// <br/>
            /// <br/>
            /// If the device is a DRM node, the DRM node type (primary vs. render) is
            /// unspecified. Clients must not rely on the compositor sending a
            /// particular node type. Clients cannot check two devices for equality by
            /// comparing the dev_t value.
            /// <br/>
            /// <br/>
            /// This event is tied to a preference tranche, see the tranche_done event.
            /// </summary>
            void OnTrancheTargetDevice(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender, ReadOnlySpan<byte> @device);

            /// <summary>
            /// This event advertises the format + modifier combinations that the
            /// compositor supports.
            /// <br/>
            /// <br/>
            /// It carries an array of indices, each referring to a format + modifier
            /// pair in the last received format table (see the format_table event).
            /// Each index is a 16-bit unsigned integer in native endianness.
            /// <br/>
            /// <br/>
            /// For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier.
            /// It indicates that the server can support the format with an implicit
            /// modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it
            /// is as if no explicit modifier is specified. The effective modifier
            /// will be derived from the dmabuf.
            /// <br/>
            /// <br/>
            /// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
            /// a given format supports both explicit modifiers and implicit modifiers.
            /// <br/>
            /// <br/>
            /// Compositors must not send duplicate format + modifier pairs within the
            /// same tranche or across two different tranches with the same target
            /// device and flags.
            /// <br/>
            /// <br/>
            /// This event is tied to a preference tranche, see the tranche_done event.
            /// <br/>
            /// <br/>
            /// For the definition of the format and modifier codes, see the
            /// wp_linux_buffer_params.create request.
            /// </summary>
            void OnTrancheFormats(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender, ReadOnlySpan<byte> @indices);

            /// <summary>
            /// This event sets tranche-specific flags.
            /// <br/>
            /// <br/>
            /// The scanout flag is a hint that direct scan-out may be attempted by the
            /// compositor on the target device if the client appropriately allocates a
            /// buffer. How to allocate a buffer that can be scanned out on the target
            /// device is implementation-defined.
            /// <br/>
            /// <br/>
            /// This event is tied to a preference tranche, see the tranche_done event.
            /// </summary>
            void OnTrancheFlags(NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1 eventSender, TrancheFlagsEnum @flags);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnDone(this);
                    break;
                case 1:
                    Events?.OnFormatTable(this, arguments[0].Int32, arguments[1].UInt32);
                    break;
                case 2:
                    Events?.OnMainDevice(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnTrancheDone(this);
                    break;
                case 4:
                    Events?.OnTrancheTargetDevice(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 5:
                    Events?.OnTrancheFormats(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 6:
                    Events?.OnTrancheFlags(this, (TrancheFlagsEnum)arguments[0].UInt32);
                    break;
            }
        }

        [Flags]
        public enum TrancheFlagsEnum
        {
            /// <summary></summary>
            Scanout = 1
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxDmabufFeedbackV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.LinuxDmabufUnstableV1.ZwpLinuxDmabufFeedbackV1.WlInterface);
            }

            public ZwpLinuxDmabufFeedbackV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxDmabufFeedbackV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxDmabufFeedbackV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_dmabuf_feedback_v1";
        public const int InterfaceVersion = 4;

        public ZwpLinuxDmabufFeedbackV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}