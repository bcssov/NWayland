using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1
{
    /// <summary>
    /// A global interface used for inhibiting the compositor keyboard shortcuts.
    /// </summary>
    public sealed unsafe partial class ZwpKeyboardShortcutsInhibitManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpKeyboardShortcutsInhibitManagerV1()
        {
            NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface = new WlInterface("zwp_keyboard_shortcuts_inhibit_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("inhibit_shortcuts", "noo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a new keyboard shortcuts inhibitor object associated with
        /// the given surface for the given seat.
        /// <br/>
        /// <br/>
        /// If shortcuts are already inhibited for the specified seat and surface,
        /// a protocol error "already_inhibited" is raised by the compositor.
        /// </summary>
        public NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 InhibitShortcuts(NWayland.Protocols.Wayland.WlSurface @surface, NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary></summary>
            AlreadyInhibited = 0
        }

        private class ProxyFactory : IBindFactory<ZwpKeyboardShortcutsInhibitManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface);
            }

            public ZwpKeyboardShortcutsInhibitManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwpKeyboardShortcutsInhibitManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwpKeyboardShortcutsInhibitManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_keyboard_shortcuts_inhibit_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwpKeyboardShortcutsInhibitManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A keyboard shortcuts inhibitor instructs the compositor to ignore
    /// its own keyboard shortcuts when the associated surface has keyboard
    /// focus. As a result, when the surface has keyboard focus on the given
    /// seat, it will receive all key events originating from the specified
    /// seat, even those which would normally be caught by the compositor for
    /// its own shortcuts.
    /// <br/>
    /// <br/>
    /// The Wayland compositor is however under no obligation to disable
    /// all of its shortcuts, and may keep some special key combo for its own
    /// use, including but not limited to one allowing the user to forcibly
    /// restore normal keyboard events routing in the case of an unwilling
    /// client. The compositor may also use the same key combo to reactivate
    /// an existing shortcut inhibitor that was previously deactivated on
    /// user request.
    /// <br/>
    /// <br/>
    /// When the compositor restores its own keyboard shortcuts, an
    /// "inactive" event is emitted to notify the client that the keyboard
    /// shortcuts inhibitor is not effectively active for the surface and
    /// seat any more, and the client should not expect to receive all
    /// keyboard events.
    /// <br/>
    /// <br/>
    /// When the keyboard shortcuts inhibitor is inactive, the client has
    /// no way to forcibly reactivate the keyboard shortcuts inhibitor.
    /// <br/>
    /// <br/>
    /// The user can chose to re-enable a previously deactivated keyboard
    /// shortcuts inhibitor using any mechanism the compositor may offer,
    /// in which case the compositor will send an "active" event to notify
    /// the client.
    /// <br/>
    /// <br/>
    /// If the surface is destroyed, unmapped, or loses the seat's keyboard
    /// focus, the keyboard shortcuts inhibitor becomes irrelevant and the
    /// compositor will restore its own keyboard shortcuts but no "inactive"
    /// event is emitted in this case.
    /// </summary>
    public sealed unsafe partial class ZwpKeyboardShortcutsInhibitorV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpKeyboardShortcutsInhibitorV1()
        {
            NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface = new WlInterface("zwp_keyboard_shortcuts_inhibitor_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("active", "", new WlInterface*[] { }),
                new WlMessage("inactive", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event indicates that the shortcut inhibitor is active.
            /// <br/>
            /// <br/>
            /// The compositor sends this event every time compositor shortcuts
            /// are inhibited on behalf of the surface. When active, the client
            /// may receive input events normally reserved by the compositor
            /// (see zwp_keyboard_shortcuts_inhibitor_v1).
            /// <br/>
            /// <br/>
            /// This occurs typically when the initial request "inhibit_shortcuts"
            /// first becomes active or when the user instructs the compositor to
            /// re-enable and existing shortcuts inhibitor using any mechanism
            /// offered by the compositor.
            /// </summary>
            void OnActive(NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 eventSender);

            /// <summary>
            /// This event indicates that the shortcuts inhibitor is inactive,
            /// normal shortcuts processing is restored by the compositor.
            /// </summary>
            void OnInactive(NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnActive(this);
                    break;
                case 1:
                    Events?.OnInactive(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpKeyboardShortcutsInhibitorV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface);
            }

            public ZwpKeyboardShortcutsInhibitorV1 Create(IntPtr handle, int version)
            {
                return new ZwpKeyboardShortcutsInhibitorV1(handle, version);
            }
        }

        public static IBindFactory<ZwpKeyboardShortcutsInhibitorV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_keyboard_shortcuts_inhibitor_v1";
        public const int InterfaceVersion = 1;

        public ZwpKeyboardShortcutsInhibitorV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}