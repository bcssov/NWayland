using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.TabletUnstableV2
{
    /// <summary>
    /// An object that provides access to the graphics tablets available on this
    /// system. All tablets are associated with a seat, to get access to the
    /// actual tablets, use wp_tablet_manager.get_tablet_seat.
    /// </summary>
    public sealed unsafe partial class ZwpTabletManagerV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletManagerV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface = new WlInterface("zwp_tablet_manager_v2", 1, new WlMessage[] {
                new WlMessage("get_tablet_seat", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface);
        }

        /// <summary>
        /// Get the wp_tablet_seat object for the given seat. This object
        /// provides access to all graphics tablets in this seat.
        /// </summary>
        public NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 GetTabletSeat(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpTabletManagerV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface);
            }

            public ZwpTabletManagerV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletManagerV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletManagerV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_manager_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletManagerV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An object that provides access to the graphics tablets available on this
    /// seat. After binding to this interface, the compositor sends a set of
    /// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
    /// </summary>
    public sealed unsafe partial class ZwpTabletSeatV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletSeatV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface = new WlInterface("zwp_tablet_seat_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("tablet_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface) }),
                new WlMessage("tool_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface) }),
                new WlMessage("pad_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent whenever a new tablet becomes available on this
            /// seat. This event only provides the object id of the tablet, any
            /// static information about the tablet (device name, vid/pid, etc.) is
            /// sent through the wp_tablet interface.
            /// </summary>
            void OnTabletAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletV2 @id);

            /// <summary>
            /// This event is sent whenever a tool that has not previously been used
            /// with a tablet comes into use. This event only provides the object id
            /// of the tool; any static information about the tool (capabilities,
            /// type, etc.) is sent through the wp_tablet_tool interface.
            /// </summary>
            void OnToolAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletToolV2 @id);

            /// <summary>
            /// This event is sent whenever a new pad is known to the system. Typically,
            /// pads are physically attached to tablets and a pad_added event is
            /// sent immediately after the wp_tablet_seat.tablet_added.
            /// However, some standalone pad devices logically attach to tablets at
            /// runtime, and the client must wait for wp_tablet_pad.enter to know
            /// the tablet a pad is attached to.
            /// <br/>
            /// <br/>
            /// This event only provides the object id of the pad. All further
            /// features (buttons, strips, rings) are sent through the wp_tablet_pad
            /// interface.
            /// </summary>
            void OnPadAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletPadV2 @id);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnTabletAdded(this, new ZwpTabletV2(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnToolAdded(this, new ZwpTabletToolV2(arguments[0].IntPtr, Version));
                    break;
                case 2:
                    Events?.OnPadAdded(this, new ZwpTabletPadV2(arguments[0].IntPtr, Version));
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletSeatV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface);
            }

            public ZwpTabletSeatV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletSeatV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletSeatV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_seat_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletSeatV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An object that represents a physical tool that has been, or is
    /// currently in use with a tablet in this seat. Each wp_tablet_tool
    /// object stays valid until the client destroys it; the compositor
    /// reuses the wp_tablet_tool object to indicate that the object's
    /// respective physical tool has come into proximity of a tablet again.
    /// <br/>
    /// <br/>
    /// A wp_tablet_tool object's relation to a physical tool depends on the
    /// tablet's ability to report serial numbers. If the tablet supports
    /// this capability, then the object represents a specific physical tool
    /// and can be identified even when used on multiple tablets.
    /// <br/>
    /// <br/>
    /// A tablet tool has a number of static characteristics, e.g. tool type,
    /// hardware_serial and capabilities. These capabilities are sent in an
    /// event sequence after the wp_tablet_seat.tool_added event before any
    /// actual events from this tool. This initial event sequence is
    /// terminated by a wp_tablet_tool.done event.
    /// <br/>
    /// <br/>
    /// Tablet tool events are grouped by wp_tablet_tool.frame events.
    /// Any events received before a wp_tablet_tool.frame event should be
    /// considered part of the same hardware state change.
    /// </summary>
    public sealed unsafe partial class ZwpTabletToolV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletToolV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface = new WlInterface("zwp_tablet_tool_v2", 1, new WlMessage[] {
                new WlMessage("set_cursor", "u?oii", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("type", "u", new WlInterface*[] { null }),
                new WlMessage("hardware_serial", "uu", new WlInterface*[] { null, null }),
                new WlMessage("hardware_id_wacom", "uu", new WlInterface*[] { null, null }),
                new WlMessage("capability", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("removed", "", new WlInterface*[] { }),
                new WlMessage("proximity_in", "uoo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("proximity_out", "", new WlInterface*[] { }),
                new WlMessage("down", "u", new WlInterface*[] { null }),
                new WlMessage("up", "", new WlInterface*[] { }),
                new WlMessage("motion", "ff", new WlInterface*[] { null, null }),
                new WlMessage("pressure", "u", new WlInterface*[] { null }),
                new WlMessage("distance", "u", new WlInterface*[] { null }),
                new WlMessage("tilt", "ff", new WlInterface*[] { null, null }),
                new WlMessage("rotation", "f", new WlInterface*[] { null }),
                new WlMessage("slider", "i", new WlInterface*[] { null }),
                new WlMessage("wheel", "fi", new WlInterface*[] { null, null }),
                new WlMessage("button", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface);
        }

        /// <summary>
        /// Sets the surface of the cursor used for this tool on the given
        /// tablet. This request only takes effect if the tool is in proximity
        /// of one of the requesting client's surfaces or the surface parameter
        /// is the current pointer surface. If there was a previous surface set
        /// with this request it is replaced. If surface is NULL, the cursor
        /// image is hidden.
        /// <br/>
        /// <br/>
        /// The parameters hotspot_x and hotspot_y define the position of the
        /// pointer surface relative to the pointer location. Its top-left corner
        /// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
        /// coordinates of the pointer location, in surface-local coordinates.
        /// <br/>
        /// <br/>
        /// On surface.attach requests to the pointer surface, hotspot_x and
        /// hotspot_y are decremented by the x and y parameters passed to the
        /// request. Attach must be confirmed by wl_surface.commit as usual.
        /// <br/>
        /// <br/>
        /// The hotspot can also be updated by passing the currently set pointer
        /// surface to this request with new values for hotspot_x and hotspot_y.
        /// <br/>
        /// <br/>
        /// The current and pending input regions of the wl_surface are cleared,
        /// and wl_surface.set_input_region is ignored until the wl_surface is no
        /// longer used as the cursor. When the use as a cursor ends, the current
        /// and pending input regions become undefined, and the wl_surface is
        /// unmapped.
        /// <br/>
        /// <br/>
        /// This request gives the surface the role of a wp_tablet_tool cursor. A
        /// surface may only ever be used as the cursor surface for one
        /// wp_tablet_tool. If the surface already has another role or has
        /// previously been used as cursor surface for a different tool, a
        /// protocol error is raised.
        /// </summary>
        public void SetCursor(uint @serial, NWayland.Protocols.Wayland.WlSurface? @surface, int @hotspotX, int @hotspotY)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial,
                @surface,
                @hotspotX,
                @hotspotY
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// The tool type is the high-level type of the tool and usually decides
            /// the interaction expected from this tool.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_tool.done event.
            /// </summary>
            void OnType(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, TypeEnum @toolType);

            /// <summary>
            /// If the physical tool can be identified by a unique 64-bit serial
            /// number, this event notifies the client of this serial number.
            /// <br/>
            /// <br/>
            /// If multiple tablets are available in the same seat and the tool is
            /// uniquely identifiable by the serial number, that tool may move
            /// between tablets.
            /// <br/>
            /// <br/>
            /// Otherwise, if the tool has no serial number and this event is
            /// missing, the tool is tied to the tablet it first comes into
            /// proximity with. Even if the physical tool is used on multiple
            /// tablets, separate wp_tablet_tool objects will be created, one per
            /// tablet.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_tool.done event.
            /// </summary>
            void OnHardwareSerial(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @hardwareSerialHi, uint @hardwareSerialLo);

            /// <summary>
            /// This event notifies the client of a hardware id available on this tool.
            /// <br/>
            /// <br/>
            /// The hardware id is a device-specific 64-bit id that provides extra
            /// information about the tool in use, beyond the wl_tool.type
            /// enumeration. The format of the id is specific to tablets made by
            /// Wacom Inc. For example, the hardware id of a Wacom Grip
            /// Pen (a stylus) is 0x802.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_tool.done event.
            /// </summary>
            void OnHardwareIdWacom(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @hardwareIdHi, uint @hardwareIdLo);

            /// <summary>
            /// This event notifies the client of any capabilities of this tool,
            /// beyond the main set of x/y axes and tip up/down detection.
            /// <br/>
            /// <br/>
            /// One event is sent for each extra capability available on this tool.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_tool.done event.
            /// </summary>
            void OnCapability(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, CapabilityEnum @capability);

            /// <summary>
            /// This event signals the end of the initial burst of descriptive
            /// events. A client may consider the static description of the tool to
            /// be complete and finalize initialization of the tool.
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// This event is sent when the tool is removed from the system and will
            /// send no further events. Should the physical tool come back into
            /// proximity later, a new wp_tablet_tool object will be created.
            /// <br/>
            /// <br/>
            /// It is compositor-dependent when a tool is removed. A compositor may
            /// remove a tool on proximity out, tablet removal or any other reason.
            /// A compositor may also keep a tool alive until shutdown.
            /// <br/>
            /// <br/>
            /// If the tool is currently in proximity, a proximity_out event will be
            /// sent before the removed event. See wp_tablet_tool.proximity_out for
            /// the handling of any buttons logically down.
            /// <br/>
            /// <br/>
            /// When this event is received, the client must wp_tablet_tool.destroy
            /// the object.
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Notification that this tool is focused on a certain surface.
            /// <br/>
            /// <br/>
            /// This event can be received when the tool has moved from one surface to
            /// another, or when the tool has come back into proximity above the
            /// surface.
            /// <br/>
            /// <br/>
            /// If any button is logically down when the tool comes into proximity,
            /// the respective button event is sent after the proximity_in event but
            /// within the same frame as the proximity_in event.
            /// </summary>
            void OnProximityIn(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial, NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 @tablet, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification that this tool has either left proximity, or is no
            /// longer focused on a certain surface.
            /// <br/>
            /// <br/>
            /// When the tablet tool leaves proximity of the tablet, button release
            /// events are sent for each button that was held down at the time of
            /// leaving proximity. These events are sent before the proximity_out
            /// event but within the same wp_tablet.frame.
            /// <br/>
            /// <br/>
            /// If the tool stays within proximity of the tablet, but the focus
            /// changes from one surface to another, a button release event may not
            /// be sent until the button is actually released or the tool leaves the
            /// proximity of the tablet.
            /// </summary>
            void OnProximityOut(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Sent whenever the tablet tool comes in contact with the surface of the
            /// tablet.
            /// <br/>
            /// <br/>
            /// If the tool is already in contact with the tablet when entering the
            /// input region, the client owning said region will receive a
            /// wp_tablet.proximity_in event, followed by a wp_tablet.down
            /// event and a wp_tablet.frame event.
            /// <br/>
            /// <br/>
            /// Note that this event describes logical contact, not physical
            /// contact. On some devices, a compositor may not consider a tool in
            /// logical contact until a minimum physical pressure threshold is
            /// exceeded.
            /// </summary>
            void OnDown(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial);

            /// <summary>
            /// Sent whenever the tablet tool stops making contact with the surface of
            /// the tablet, or when the tablet tool moves out of the input region
            /// and the compositor grab (if any) is dismissed.
            /// <br/>
            /// <br/>
            /// If the tablet tool moves out of the input region while in contact
            /// with the surface of the tablet and the compositor does not have an
            /// ongoing grab on the surface, the client owning said region will
            /// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
            /// event and a wp_tablet.frame event. If the compositor has an ongoing
            /// grab on this device, this event sequence is sent whenever the grab
            /// is dismissed in the future.
            /// <br/>
            /// <br/>
            /// Note that this event describes logical contact, not physical
            /// contact. On some devices, a compositor may not consider a tool out
            /// of logical contact until physical pressure falls below a specific
            /// threshold.
            /// </summary>
            void OnUp(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Sent whenever a tablet tool moves.
            /// </summary>
            void OnMotion(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @x, WlFixed @y);

            /// <summary>
            /// Sent whenever the pressure axis on a tool changes. The value of this
            /// event is normalized to a value between 0 and 65535.
            /// <br/>
            /// <br/>
            /// Note that pressure may be nonzero even when a tool is not in logical
            /// contact. See the down and up events for more details.
            /// </summary>
            void OnPressure(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @pressure);

            /// <summary>
            /// Sent whenever the distance axis on a tool changes. The value of this
            /// event is normalized to a value between 0 and 65535.
            /// <br/>
            /// <br/>
            /// Note that distance may be nonzero even when a tool is not in logical
            /// contact. See the down and up events for more details.
            /// </summary>
            void OnDistance(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @distance);

            /// <summary>
            /// Sent whenever one or both of the tilt axes on a tool change. Each tilt
            /// value is in degrees, relative to the z-axis of the tablet.
            /// The angle is positive when the top of a tool tilts along the
            /// positive x or y axis.
            /// </summary>
            void OnTilt(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @tiltX, WlFixed @tiltY);

            /// <summary>
            /// Sent whenever the z-rotation axis on the tool changes. The
            /// rotation value is in degrees clockwise from the tool's
            /// logical neutral position.
            /// </summary>
            void OnRotation(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @degrees);

            /// <summary>
            /// Sent whenever the slider position on the tool changes. The
            /// value is normalized between -65535 and 65535, with 0 as the logical
            /// neutral position of the slider.
            /// <br/>
            /// <br/>
            /// The slider is available on e.g. the Wacom Airbrush tool.
            /// </summary>
            void OnSlider(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, int @position);

            /// <summary>
            /// Sent whenever the wheel on the tool emits an event. This event
            /// contains two values for the same axis change. The degrees value is
            /// in the same orientation as the wl_pointer.vertical_scroll axis. The
            /// clicks value is in discrete logical clicks of the mouse wheel. This
            /// value may be zero if the movement of the wheel was less
            /// than one logical click.
            /// <br/>
            /// <br/>
            /// Clients should choose either value and avoid mixing degrees and
            /// clicks. The compositor may accumulate values smaller than a logical
            /// click and emulate click events when a certain threshold is met.
            /// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
            /// have different degrees values.
            /// </summary>
            void OnWheel(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @degrees, int @clicks);

            /// <summary>
            /// Sent whenever a button on the tool is pressed or released.
            /// <br/>
            /// <br/>
            /// If a button is held down when the tool moves in or out of proximity,
            /// button events are generated by the compositor. See
            /// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
            /// details.
            /// </summary>
            void OnButton(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial, uint @button, ButtonStateEnum @state);

            /// <summary>
            /// Marks the end of a series of axis and/or button updates from the
            /// tablet. The Wayland protocol requires axis updates to be sent
            /// sequentially, however all events within a frame should be considered
            /// one hardware event.
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnType(this, (TypeEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnHardwareSerial(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 2:
                    Events?.OnHardwareIdWacom(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 3:
                    Events?.OnCapability(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
                case 4:
                    Events?.OnDone(this);
                    break;
                case 5:
                    Events?.OnRemoved(this);
                    break;
                case 6:
                    Events?.OnProximityIn(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.TabletUnstableV2.ZwpTabletV2>(arguments[1].IntPtr), WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr));
                    break;
                case 7:
                    Events?.OnProximityOut(this);
                    break;
                case 8:
                    Events?.OnDown(this, arguments[0].UInt32);
                    break;
                case 9:
                    Events?.OnUp(this);
                    break;
                case 10:
                    Events?.OnMotion(this, arguments[0].WlFixed, arguments[1].WlFixed);
                    break;
                case 11:
                    Events?.OnPressure(this, arguments[0].UInt32);
                    break;
                case 12:
                    Events?.OnDistance(this, arguments[0].UInt32);
                    break;
                case 13:
                    Events?.OnTilt(this, arguments[0].WlFixed, arguments[1].WlFixed);
                    break;
                case 14:
                    Events?.OnRotation(this, arguments[0].WlFixed);
                    break;
                case 15:
                    Events?.OnSlider(this, arguments[0].Int32);
                    break;
                case 16:
                    Events?.OnWheel(this, arguments[0].WlFixed, arguments[1].Int32);
                    break;
                case 17:
                    Events?.OnButton(this, arguments[0].UInt32, arguments[1].UInt32, (ButtonStateEnum)arguments[2].UInt32);
                    break;
                case 18:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the physical type of a tool. The physical type of a tool
        /// generally defines its base usage.
        /// <br/>
        /// <br/>
        /// The mouse tool represents a mouse-shaped tool that is not a relative
        /// device but bound to the tablet's surface, providing absolute
        /// coordinates.
        /// <br/>
        /// <br/>
        /// The lens tool is a mouse-shaped tool with an attached lens to
        /// provide precision focus.
        /// </summary>
        public enum TypeEnum
        {
            /// <summary></summary>
            Pen = 0x140,
            /// <summary></summary>
            Eraser = 0x141,
            /// <summary></summary>
            Brush = 0x142,
            /// <summary></summary>
            Pencil = 0x143,
            /// <summary></summary>
            Airbrush = 0x144,
            /// <summary></summary>
            Finger = 0x145,
            /// <summary></summary>
            Mouse = 0x146,
            /// <summary></summary>
            Lens = 0x147
        }

        /// <summary>
        /// Describes extra capabilities on a tablet.
        /// <br/>
        /// <br/>
        /// Any tool must provide x and y values, extra axes are
        /// device-specific.
        /// </summary>
        public enum CapabilityEnum
        {
            /// <summary></summary>
            Tilt = 1,
            /// <summary></summary>
            Pressure = 2,
            /// <summary></summary>
            Distance = 3,
            /// <summary></summary>
            Rotation = 4,
            /// <summary></summary>
            Slider = 5,
            /// <summary></summary>
            Wheel = 6
        }

        /// <summary>
        /// Describes the physical state of a button that produced the button event.
        /// </summary>
        public enum ButtonStateEnum
        {
            /// <summary></summary>
            Released = 0,
            /// <summary></summary>
            Pressed = 1
        }

        public enum ErrorEnum
        {
            /// <summary></summary>
            Role = 0
        }

        private class ProxyFactory : IBindFactory<ZwpTabletToolV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface);
            }

            public ZwpTabletToolV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletToolV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletToolV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_tool_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletToolV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wp_tablet interface represents one graphics tablet device. The
    /// tablet interface itself does not generate events; all events are
    /// generated by wp_tablet_tool objects when in proximity above a tablet.
    /// <br/>
    /// <br/>
    /// A tablet has a number of static characteristics, e.g. device name and
    /// pid/vid. These capabilities are sent in an event sequence after the
    /// wp_tablet_seat.tablet_added event. This initial event sequence is
    /// terminated by a wp_tablet.done event.
    /// </summary>
    public sealed unsafe partial class ZwpTabletV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface = new WlInterface("zwp_tablet_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("name", "s", new WlInterface*[] { null }),
                new WlMessage("id", "uu", new WlInterface*[] { null, null }),
                new WlMessage("path", "s", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("removed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet.done event.
            /// </summary>
            void OnName(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, string @name);

            /// <summary>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet.done event.
            /// </summary>
            void OnId(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, uint @vid, uint @pid);

            /// <summary>
            /// A system-specific device path that indicates which device is behind
            /// this wp_tablet. This information may be used to gather additional
            /// information about the device, e.g. through libwacom.
            /// <br/>
            /// <br/>
            /// A device may have more than one device path. If so, multiple
            /// wp_tablet.path events are sent. A device may be emulated and not
            /// have a device path, and in that case this event will not be sent.
            /// <br/>
            /// <br/>
            /// The format of the path is unspecified, it may be a device node, a
            /// sysfs path, or some other identifier. It is up to the client to
            /// identify the string provided.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet.done event.
            /// </summary>
            void OnPath(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, string @path);

            /// <summary>
            /// This event is sent immediately to signal the end of the initial
            /// burst of descriptive events. A client may consider the static
            /// description of the tablet to be complete and finalize initialization
            /// of the tablet.
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender);

            /// <summary>
            /// Sent when the tablet has been removed from the system. When a tablet
            /// is removed, some tools may be removed.
            /// <br/>
            /// <br/>
            /// When this event is received, the client must wp_tablet.destroy
            /// the object.
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnId(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 2:
                    Events?.OnPath(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnDone(this);
                    break;
                case 4:
                    Events?.OnRemoved(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface);
            }

            public ZwpTabletV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A circular interaction area, such as the touch ring on the Wacom Intuos
    /// Pro series tablets.
    /// <br/>
    /// <br/>
    /// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
    /// event.
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadRingV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadRingV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface = new WlInterface("zwp_tablet_pad_ring_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "su", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("source", "u", new WlInterface*[] { null }),
                new WlMessage("angle", "f", new WlInterface*[] { null }),
                new WlMessage("stop", "", new WlInterface*[] { }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface);
        }

        /// <summary>
        /// Request that the compositor use the provided feedback string
        /// associated with this ring. This request should be issued immediately
        /// after a wp_tablet_pad_group.mode_switch event from the corresponding
        /// group is received, or whenever the ring is mapped to a different
        /// action. See wp_tablet_pad_group.mode_switch for more details.
        /// <br/>
        /// <br/>
        /// Clients are encouraged to provide context-aware descriptions for
        /// the actions associated with the ring; compositors may use this
        /// information to offer visual feedback about the button layout
        /// (eg. on-screen displays).
        /// <br/>
        /// <br/>
        /// The provided string 'description' is a UTF-8 encoded string to be
        /// associated with this ring, and is considered user-visible; general
        /// internationalization rules apply.
        /// <br/>
        /// <br/>
        /// The serial argument will be that of the last
        /// wp_tablet_pad_group.mode_switch event received for the group of this
        /// ring. Requests providing other serials than the most recent one will be
        /// ignored.
        /// </summary>
        public void SetFeedback(string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Source information for ring events.
            /// <br/>
            /// <br/>
            /// This event does not occur on its own. It is sent before a
            /// wp_tablet_pad_ring.frame event and carries the source information
            /// for all events within that frame.
            /// <br/>
            /// <br/>
            /// The source specifies how this event was generated. If the source is
            /// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
            /// will be sent when the user lifts the finger off the device.
            /// <br/>
            /// <br/>
            /// This event is optional. If the source is unknown for an interaction,
            /// no event is sent.
            /// </summary>
            void OnSource(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, SourceEnum @source);

            /// <summary>
            /// Sent whenever the angle on a ring changes.
            /// <br/>
            /// <br/>
            /// The angle is provided in degrees clockwise from the logical
            /// north of the ring in the pad's current rotation.
            /// </summary>
            void OnAngle(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, WlFixed @degrees);

            /// <summary>
            /// Stop notification for ring events.
            /// <br/>
            /// <br/>
            /// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
            /// event is sent to notify a client that the interaction with the ring
            /// has terminated. This enables the client to implement kinetic scrolling.
            /// See the wp_tablet_pad_ring.source documentation for information on
            /// when this event may be generated.
            /// <br/>
            /// <br/>
            /// Any wp_tablet_pad_ring.angle events with the same source after this
            /// event should be considered as the start of a new interaction.
            /// </summary>
            void OnStop(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender);

            /// <summary>
            /// Indicates the end of a set of ring events that logically belong
            /// together. A client is expected to accumulate the data in all events
            /// within the frame before proceeding.
            /// <br/>
            /// <br/>
            /// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
            /// logically together. For example, on termination of a finger interaction
            /// on a ring the compositor will send a wp_tablet_pad_ring.source event,
            /// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
            /// <br/>
            /// <br/>
            /// A wp_tablet_pad_ring.frame event is sent for every logical event
            /// group, even if the group only contains a single wp_tablet_pad_ring
            /// event. Specifically, a client may get a sequence: angle, frame,
            /// angle, frame, etc.
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSource(this, (SourceEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnAngle(this, arguments[0].WlFixed);
                    break;
                case 2:
                    Events?.OnStop(this);
                    break;
                case 3:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the source types for ring events. This indicates to the
        /// client how a ring event was physically generated; a client may
        /// adjust the user interface accordingly. For example, events
        /// from a "finger" source may trigger kinetic scrolling.
        /// </summary>
        public enum SourceEnum
        {
            /// <summary></summary>
            Finger = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadRingV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface);
            }

            public ZwpTabletPadRingV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadRingV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadRingV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_ring_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadRingV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A linear interaction area, such as the strips found in Wacom Cintiq
    /// models.
    /// <br/>
    /// <br/>
    /// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
    /// event.
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadStripV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadStripV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface = new WlInterface("zwp_tablet_pad_strip_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "su", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("source", "u", new WlInterface*[] { null }),
                new WlMessage("position", "u", new WlInterface*[] { null }),
                new WlMessage("stop", "", new WlInterface*[] { }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface);
        }

        /// <summary>
        /// Requests the compositor to use the provided feedback string
        /// associated with this strip. This request should be issued immediately
        /// after a wp_tablet_pad_group.mode_switch event from the corresponding
        /// group is received, or whenever the strip is mapped to a different
        /// action. See wp_tablet_pad_group.mode_switch for more details.
        /// <br/>
        /// <br/>
        /// Clients are encouraged to provide context-aware descriptions for
        /// the actions associated with the strip, and compositors may use this
        /// information to offer visual feedback about the button layout
        /// (eg. on-screen displays).
        /// <br/>
        /// <br/>
        /// The provided string 'description' is a UTF-8 encoded string to be
        /// associated with this ring, and is considered user-visible; general
        /// internationalization rules apply.
        /// <br/>
        /// <br/>
        /// The serial argument will be that of the last
        /// wp_tablet_pad_group.mode_switch event received for the group of this
        /// strip. Requests providing other serials than the most recent one will be
        /// ignored.
        /// </summary>
        public void SetFeedback(string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Source information for strip events.
            /// <br/>
            /// <br/>
            /// This event does not occur on its own. It is sent before a
            /// wp_tablet_pad_strip.frame event and carries the source information
            /// for all events within that frame.
            /// <br/>
            /// <br/>
            /// The source specifies how this event was generated. If the source is
            /// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
            /// will be sent when the user lifts their finger off the device.
            /// <br/>
            /// <br/>
            /// This event is optional. If the source is unknown for an interaction,
            /// no event is sent.
            /// </summary>
            void OnSource(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, SourceEnum @source);

            /// <summary>
            /// Sent whenever the position on a strip changes.
            /// <br/>
            /// <br/>
            /// The position is normalized to a range of [0, 65535], the 0-value
            /// represents the top-most and/or left-most position of the strip in
            /// the pad's current rotation.
            /// </summary>
            void OnPosition(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, uint @position);

            /// <summary>
            /// Stop notification for strip events.
            /// <br/>
            /// <br/>
            /// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
            /// event is sent to notify a client that the interaction with the strip
            /// has terminated. This enables the client to implement kinetic
            /// scrolling. See the wp_tablet_pad_strip.source documentation for
            /// information on when this event may be generated.
            /// <br/>
            /// <br/>
            /// Any wp_tablet_pad_strip.position events with the same source after this
            /// event should be considered as the start of a new interaction.
            /// </summary>
            void OnStop(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender);

            /// <summary>
            /// Indicates the end of a set of events that represent one logical
            /// hardware strip event. A client is expected to accumulate the data
            /// in all events within the frame before proceeding.
            /// <br/>
            /// <br/>
            /// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
            /// logically together. For example, on termination of a finger interaction
            /// on a strip the compositor will send a wp_tablet_pad_strip.source event,
            /// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
            /// event.
            /// <br/>
            /// <br/>
            /// A wp_tablet_pad_strip.frame event is sent for every logical event
            /// group, even if the group only contains a single wp_tablet_pad_strip
            /// event. Specifically, a client may get a sequence: position, frame,
            /// position, frame, etc.
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSource(this, (SourceEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnPosition(this, arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnStop(this);
                    break;
                case 3:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the source types for strip events. This indicates to the
        /// client how a strip event was physically generated; a client may
        /// adjust the user interface accordingly. For example, events
        /// from a "finger" source may trigger kinetic scrolling.
        /// </summary>
        public enum SourceEnum
        {
            /// <summary></summary>
            Finger = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadStripV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface);
            }

            public ZwpTabletPadStripV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadStripV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadStripV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_strip_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadStripV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pad group describes a distinct (sub)set of buttons, rings and strips
    /// present in the tablet. The criteria of this grouping is usually positional,
    /// eg. if a tablet has buttons on the left and right side, 2 groups will be
    /// presented. The physical arrangement of groups is undisclosed and may
    /// change on the fly.
    /// <br/>
    /// <br/>
    /// Pad groups will announce their features during pad initialization. Between
    /// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
    /// pad group will announce the buttons, rings and strips contained in it,
    /// plus the number of supported modes.
    /// <br/>
    /// <br/>
    /// Modes are a mechanism to allow multiple groups of actions for every element
    /// in the pad group. The number of groups and available modes in each is
    /// persistent across device plugs. The current mode is user-switchable, it
    /// will be announced through the wp_tablet_pad_group.mode_switch event both
    /// whenever it is switched, and after wp_tablet_pad.enter.
    /// <br/>
    /// <br/>
    /// The current mode logically applies to all elements in the pad group,
    /// although it is at clients' discretion whether to actually perform different
    /// actions, and/or issue the respective .set_feedback requests to notify the
    /// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadGroupV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadGroupV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface = new WlInterface("zwp_tablet_pad_group_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("buttons", "a", new WlInterface*[] { null }),
                new WlMessage("ring", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface) }),
                new WlMessage("strip", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface) }),
                new WlMessage("modes", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("mode_switch", "uuu", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce the available
            /// buttons in the group. Button indices start at 0, a button may only be
            /// in one group at a time.
            /// <br/>
            /// <br/>
            /// This event is first sent in the initial burst of events before the
            /// wp_tablet_pad_group.done event.
            /// <br/>
            /// <br/>
            /// Some buttons are reserved by the compositor. These buttons may not be
            /// assigned to any wp_tablet_pad_group. Compositors may broadcast this
            /// event in the case of changes to the mapping of these reserved buttons.
            /// If the compositor happens to reserve all buttons in a group, this event
            /// will be sent with an empty array.
            /// </summary>
            void OnButtons(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ReadOnlySpan<byte> @buttons);

            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce available rings.
            /// One event is sent for each ring available on this pad group.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad_group.done event.
            /// </summary>
            void OnRing(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ZwpTabletPadRingV2 @ring);

            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce available strips.
            /// One event is sent for each strip available on this pad group.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad_group.done event.
            /// </summary>
            void OnStrip(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ZwpTabletPadStripV2 @strip);

            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce that the pad
            /// group may switch between modes. A client may use a mode to store a
            /// specific configuration for buttons, rings and strips and use the
            /// wl_tablet_pad_group.mode_switch event to toggle between these
            /// configurations. Mode indices start at 0.
            /// <br/>
            /// <br/>
            /// Switching modes is compositor-dependent. See the
            /// wp_tablet_pad_group.mode_switch event for more details.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad_group.done event. This event is only sent when more than
            /// more than one mode is available.
            /// </summary>
            void OnModes(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, uint @modes);

            /// <summary>
            /// This event is sent immediately to signal the end of the initial
            /// burst of descriptive events. A client may consider the static
            /// description of the tablet to be complete and finalize initialization
            /// of the tablet group.
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender);

            /// <summary>
            /// Notification that the mode was switched.
            /// <br/>
            /// <br/>
            /// A mode applies to all buttons, rings and strips in a group
            /// simultaneously, but a client is not required to assign different actions
            /// for each mode. For example, a client may have mode-specific button
            /// mappings but map the ring to vertical scrolling in all modes. Mode
            /// indices start at 0.
            /// <br/>
            /// <br/>
            /// Switching modes is compositor-dependent. The compositor may provide
            /// visual cues to the client about the mode, e.g. by toggling LEDs on
            /// the tablet device. Mode-switching may be software-controlled or
            /// controlled by one or more physical buttons. For example, on a Wacom
            /// Intuos Pro, the button inside the ring may be assigned to switch
            /// between modes.
            /// <br/>
            /// <br/>
            /// The compositor will also send this event after wp_tablet_pad.enter on
            /// each group in order to notify of the current mode. Groups that only
            /// feature one mode will use mode=0 when emitting this event.
            /// <br/>
            /// <br/>
            /// If a button action in the new mode differs from the action in the
            /// previous mode, the client should immediately issue a
            /// wp_tablet_pad.set_feedback request for each changed button.
            /// <br/>
            /// <br/>
            /// If a ring or strip action in the new mode differs from the action
            /// in the previous mode, the client should immediately issue a
            /// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
            /// for each changed ring or strip.
            /// </summary>
            void OnModeSwitch(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, uint @time, uint @serial, uint @mode);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnButtons(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnRing(this, new ZwpTabletPadRingV2(arguments[0].IntPtr, Version));
                    break;
                case 2:
                    Events?.OnStrip(this, new ZwpTabletPadStripV2(arguments[0].IntPtr, Version));
                    break;
                case 3:
                    Events?.OnModes(this, arguments[0].UInt32);
                    break;
                case 4:
                    Events?.OnDone(this);
                    break;
                case 5:
                    Events?.OnModeSwitch(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadGroupV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface);
            }

            public ZwpTabletPadGroupV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadGroupV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadGroupV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_group_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadGroupV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pad device is a set of buttons, rings and strips
    /// usually physically present on the tablet device itself. Some
    /// exceptions exist where the pad device is physically detached, e.g. the
    /// Wacom ExpressKey Remote.
    /// <br/>
    /// <br/>
    /// Pad devices have no axes that control the cursor and are generally
    /// auxiliary devices to the tool devices used on the tablet surface.
    /// <br/>
    /// <br/>
    /// A pad device has a number of static characteristics, e.g. the number
    /// of rings. These capabilities are sent in an event sequence after the
    /// wp_tablet_seat.pad_added event before any actual events from this pad.
    /// This initial event sequence is terminated by a wp_tablet_pad.done
    /// event.
    /// <br/>
    /// <br/>
    /// All pad features (buttons, rings and strips) are logically divided into
    /// groups and all pads have at least one group. The available groups are
    /// notified through the wp_tablet_pad.group event; the compositor will
    /// emit one event per group before emitting wp_tablet_pad.done.
    /// <br/>
    /// <br/>
    /// Groups may have multiple modes. Modes allow clients to map multiple
    /// actions to a single pad feature. Only one mode can be active per group,
    /// although different groups may have different active modes.
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface = new WlInterface("zwp_tablet_pad_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "usu", new WlInterface*[] { null, null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("group", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface) }),
                new WlMessage("path", "s", new WlInterface*[] { null }),
                new WlMessage("buttons", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("button", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("enter", "uoo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("leave", "uo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("removed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface);
        }

        /// <summary>
        /// Requests the compositor to use the provided feedback string
        /// associated with this button. This request should be issued immediately
        /// after a wp_tablet_pad_group.mode_switch event from the corresponding
        /// group is received, or whenever a button is mapped to a different
        /// action. See wp_tablet_pad_group.mode_switch for more details.
        /// <br/>
        /// <br/>
        /// Clients are encouraged to provide context-aware descriptions for
        /// the actions associated with each button, and compositors may use
        /// this information to offer visual feedback on the button layout
        /// (e.g. on-screen displays).
        /// <br/>
        /// <br/>
        /// Button indices start at 0. Setting the feedback string on a button
        /// that is reserved by the compositor (i.e. not belonging to any
        /// wp_tablet_pad_group) does not generate an error but the compositor
        /// is free to ignore the request.
        /// <br/>
        /// <br/>
        /// The provided string 'description' is a UTF-8 encoded string to be
        /// associated with this ring, and is considered user-visible; general
        /// internationalization rules apply.
        /// <br/>
        /// <br/>
        /// The serial argument will be that of the last
        /// wp_tablet_pad_group.mode_switch event received for the group of this
        /// button. Requests providing other serials than the most recent one will
        /// be ignored.
        /// </summary>
        public void SetFeedback(uint @button, string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                @button,
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce available groups.
            /// One event is sent for each pad group available.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad.done event. At least one group will be announced.
            /// </summary>
            void OnGroup(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, ZwpTabletPadGroupV2 @padGroup);

            /// <summary>
            /// A system-specific device path that indicates which device is behind
            /// this wp_tablet_pad. This information may be used to gather additional
            /// information about the device, e.g. through libwacom.
            /// <br/>
            /// <br/>
            /// The format of the path is unspecified, it may be a device node, a
            /// sysfs path, or some other identifier. It is up to the client to
            /// identify the string provided.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad.done event.
            /// </summary>
            void OnPath(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, string @path);

            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce the available
            /// buttons.
            /// <br/>
            /// <br/>
            /// This event is sent in the initial burst of events before the
            /// wp_tablet_pad.done event. This event is only sent when at least one
            /// button is available.
            /// </summary>
            void OnButtons(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @buttons);

            /// <summary>
            /// This event signals the end of the initial burst of descriptive
            /// events. A client may consider the static description of the pad to
            /// be complete and finalize initialization of the pad.
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender);

            /// <summary>
            /// Sent whenever the physical state of a button changes.
            /// </summary>
            void OnButton(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @time, uint @button, ButtonStateEnum @state);

            /// <summary>
            /// Notification that this pad is focused on the specified surface.
            /// </summary>
            void OnEnter(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @serial, NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 @tablet, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification that this pad is no longer focused on the specified
            /// surface.
            /// </summary>
            void OnLeave(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Sent when the pad has been removed from the system. When a tablet
            /// is removed its pad(s) will be removed too.
            /// <br/>
            /// <br/>
            /// When this event is received, the client must destroy all rings, strips
            /// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
            /// the pad itself.
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGroup(this, new ZwpTabletPadGroupV2(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnPath(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnButtons(this, arguments[0].UInt32);
                    break;
                case 3:
                    Events?.OnDone(this);
                    break;
                case 4:
                    Events?.OnButton(this, arguments[0].UInt32, arguments[1].UInt32, (ButtonStateEnum)arguments[2].UInt32);
                    break;
                case 5:
                    Events?.OnEnter(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.TabletUnstableV2.ZwpTabletV2>(arguments[1].IntPtr), WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr));
                    break;
                case 6:
                    Events?.OnLeave(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr));
                    break;
                case 7:
                    Events?.OnRemoved(this);
                    break;
            }
        }

        /// <summary>
        /// Describes the physical state of a button that caused the button
        /// event.
        /// </summary>
        public enum ButtonStateEnum
        {
            /// <summary></summary>
            Released = 0,
            /// <summary></summary>
            Pressed = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface);
            }

            public ZwpTabletPadV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}