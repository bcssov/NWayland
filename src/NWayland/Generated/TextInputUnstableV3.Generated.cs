using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.TextInputUnstableV3
{
    /// <summary>
    /// The zwp_text_input_v3 interface represents text input and input methods
    /// associated with a seat. It provides enter/leave events to follow the
    /// text input focus for a seat.
    /// <br/>
    /// <br/>
    /// Requests are used to enable/disable the text-input object and set
    /// state information like surrounding and selected text or the content type.
    /// The information about the entered text is sent to the text-input object
    /// via the preedit_string and commit_string events.
    /// <br/>
    /// <br/>
    /// Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
    /// must not point to middle bytes inside a code point: they must either
    /// point to the first byte of a code point or to the end of the buffer.
    /// Lengths must be measured between two valid indices.
    /// <br/>
    /// <br/>
    /// Focus moving throughout surfaces will result in the emission of
    /// zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
    /// surface must commit zwp_text_input_v3.enable and
    /// zwp_text_input_v3.disable requests as the keyboard focus moves across
    /// editable and non-editable elements of the UI. Those two requests are not
    /// expected to be paired with each other, the compositor must be able to
    /// handle consecutive series of the same request.
    /// <br/>
    /// <br/>
    /// State is sent by the state requests (set_surrounding_text,
    /// set_content_type and set_cursor_rectangle) and a commit request. After an
    /// enter event or disable request all state information is invalidated and
    /// needs to be resent by the client.
    /// </summary>
    public sealed unsafe partial class ZwpTextInputV3 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTextInputV3()
        {
            NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3.WlInterface = new WlInterface("zwp_text_input_v3", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("enable", "", new WlInterface*[] { }),
                new WlMessage("disable", "", new WlInterface*[] { }),
                new WlMessage("set_surrounding_text", "sii", new WlInterface*[] { null, null, null }),
                new WlMessage("set_text_change_cause", "u", new WlInterface*[] { null }),
                new WlMessage("set_content_type", "uu", new WlInterface*[] { null, null }),
                new WlMessage("set_cursor_rectangle", "iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("commit", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("enter", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("leave", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("preedit_string", "?sii", new WlInterface*[] { null, null, null }),
                new WlMessage("commit_string", "?s", new WlInterface*[] { null }),
                new WlMessage("delete_surrounding_text", "uu", new WlInterface*[] { null, null }),
                new WlMessage("done", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Requests text input on the surface previously obtained from the enter
        /// event.
        /// <br/>
        /// <br/>
        /// This request must be issued every time the active text input changes
        /// to a new one, including within the current surface. Use
        /// zwp_text_input_v3.disable when there is no longer any input focus on
        /// the current surface.
        /// <br/>
        /// <br/>
        /// Clients must not enable more than one text input on the single seat
        /// and should disable the current text input before enabling the new one.
        /// At most one instance of text input may be in enabled state per instance,
        /// Requests to enable the another text input when some text input is active
        /// must be ignored by compositor.
        /// <br/>
        /// <br/>
        /// This request resets all state associated with previous enable, disable,
        /// set_surrounding_text, set_text_change_cause, set_content_type, and
        /// set_cursor_rectangle requests, as well as the state associated with
        /// preedit_string, commit_string, and delete_surrounding_text events.
        /// <br/>
        /// <br/>
        /// The set_surrounding_text, set_content_type and set_cursor_rectangle
        /// requests must follow if the text input supports the necessary
        /// functionality.
        /// <br/>
        /// <br/>
        /// State set with this request is double-buffered. It will get applied on
        /// the next zwp_text_input_v3.commit request, and stay valid until the
        /// next committed enable or disable request.
        /// <br/>
        /// <br/>
        /// The changes must be applied by the compositor after issuing a
        /// zwp_text_input_v3.commit request.
        /// </summary>
        public void Enable()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Explicitly disable text input on the current surface (typically when
        /// there is no focus on any text entry inside the surface).
        /// <br/>
        /// <br/>
        /// State set with this request is double-buffered. It will get applied on
        /// the next zwp_text_input_v3.commit request.
        /// </summary>
        public void Disable()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Sets the surrounding plain text around the input, excluding the preedit
        /// text.
        /// <br/>
        /// <br/>
        /// The client should notify the compositor of any changes in any of the
        /// values carried with this request, including changes caused by handling
        /// incoming text-input events as well as changes caused by other
        /// mechanisms like keyboard typing.
        /// <br/>
        /// <br/>
        /// If the client is unaware of the text around the cursor, it should not
        /// issue this request, to signify lack of support to the compositor.
        /// <br/>
        /// <br/>
        /// Text is UTF-8 encoded, and should include the cursor position, the
        /// complete selection and additional characters before and after them.
        /// There is a maximum length of wayland messages, so text can not be
        /// longer than 4000 bytes.
        /// <br/>
        /// <br/>
        /// Cursor is the byte offset of the cursor within text buffer.
        /// <br/>
        /// <br/>
        /// Anchor is the byte offset of the selection anchor within text buffer.
        /// If there is no selected text, anchor is the same as cursor.
        /// <br/>
        /// <br/>
        /// If any preedit text is present, it is replaced with a cursor for the
        /// purpose of this event.
        /// <br/>
        /// <br/>
        /// Values set with this request are double-buffered. They will get applied
        /// on the next zwp_text_input_v3.commit request, and stay valid until the
        /// next committed enable or disable request.
        /// <br/>
        /// <br/>
        /// The initial state for affected fields is empty, meaning that the text
        /// input does not support sending surrounding text. If the empty values
        /// get applied, subsequent attempts to change them may have no effect.
        /// </summary>
        public void SetSurroundingText(string @text, int @cursor, int @anchor)
        {
            if (@text == null)
                throw new ArgumentNullException("text");
            using var __marshalled__text = new NWaylandMarshalledString(@text);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__text,
                @cursor,
                @anchor
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Tells the compositor why the text surrounding the cursor changed.
        /// <br/>
        /// <br/>
        /// Whenever the client detects an external change in text, cursor, or
        /// anchor posision, it must issue this request to the compositor. This
        /// request is intended to give the input method a chance to update the
        /// preedit text in an appropriate way, e.g. by removing it when the user
        /// starts typing with a keyboard.
        /// <br/>
        /// <br/>
        /// cause describes the source of the change.
        /// <br/>
        /// <br/>
        /// The value set with this request is double-buffered. It must be applied
        /// and reset to initial at the next zwp_text_input_v3.commit request.
        /// <br/>
        /// <br/>
        /// The initial value of cause is input_method.
        /// </summary>
        public void SetTextChangeCause(ChangeCauseEnum @cause)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@cause
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Sets the content purpose and content hint. While the purpose is the
        /// basic purpose of an input field, the hint flags allow to modify some of
        /// the behavior.
        /// <br/>
        /// <br/>
        /// Values set with this request are double-buffered. They will get applied
        /// on the next zwp_text_input_v3.commit request.
        /// Subsequent attempts to update them may have no effect. The values
        /// remain valid until the next committed enable or disable request.
        /// <br/>
        /// <br/>
        /// The initial value for hint is none, and the initial value for purpose
        /// is normal.
        /// </summary>
        public void SetContentType(ContentHintEnum @hint, ContentPurposeEnum @purpose)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@hint,
                (uint)@purpose
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Marks an area around the cursor as a x, y, width, height rectangle in
        /// surface local coordinates.
        /// <br/>
        /// <br/>
        /// Allows the compositor to put a window with word suggestions near the
        /// cursor, without obstructing the text being input.
        /// <br/>
        /// <br/>
        /// If the client is unaware of the position of edited text, it should not
        /// issue this request, to signify lack of support to the compositor.
        /// <br/>
        /// <br/>
        /// Values set with this request are double-buffered. They will get applied
        /// on the next zwp_text_input_v3.commit request, and stay valid until the
        /// next committed enable or disable request.
        /// <br/>
        /// <br/>
        /// The initial values describing a cursor rectangle are empty. That means
        /// the text input does not support describing the cursor area. If the
        /// empty values get applied, subsequent attempts to change them may have
        /// no effect.
        /// </summary>
        public void SetCursorRectangle(int @x, int @y, int @width, int @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        /// <summary>
        /// Atomically applies state changes recently sent to the compositor.
        /// <br/>
        /// <br/>
        /// The commit request establishes and updates the state of the client, and
        /// must be issued after any changes to apply them.
        /// <br/>
        /// <br/>
        /// Text input state (enabled status, content purpose, content hint,
        /// surrounding text and change cause, cursor rectangle) is conceptually
        /// double-buffered within the context of a text input, i.e. between a
        /// committed enable request and the following committed enable or disable
        /// request.
        /// <br/>
        /// <br/>
        /// Protocol requests modify the pending state, as opposed to the current
        /// state in use by the input method. A commit request atomically applies
        /// all pending state, replacing the current state. After commit, the new
        /// pending state is as documented for each related request.
        /// <br/>
        /// <br/>
        /// Requests are applied in the order of arrival.
        /// <br/>
        /// <br/>
        /// Neither current nor pending state are modified unless noted otherwise.
        /// <br/>
        /// <br/>
        /// The compositor must count the number of commit requests coming from
        /// each zwp_text_input_v3 object and use the count as the serial in done
        /// events.
        /// </summary>
        public void Commit()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Notification that this seat's text-input focus is on a certain surface.
            /// <br/>
            /// <br/>
            /// If client has created multiple text input objects, compositor must send
            /// this event to all of them.
            /// <br/>
            /// <br/>
            /// When the seat has the keyboard capability the text-input focus follows
            /// the keyboard focus. This event sets the current surface for the
            /// text-input object.
            /// </summary>
            void OnEnter(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification that this seat's text-input focus is no longer on a
            /// certain surface. The client should reset any preedit string previously
            /// set.
            /// <br/>
            /// <br/>
            /// The leave notification clears the current surface. It is sent before
            /// the enter notification for the new focus. After leave event, compositor
            /// must ignore requests from any text input instances until next enter
            /// event.
            /// <br/>
            /// <br/>
            /// When the seat has the keyboard capability the text-input focus follows
            /// the keyboard focus.
            /// </summary>
            void OnLeave(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notify when a new composing text (pre-edit) should be set at the
            /// current cursor position. Any previously set composing text must be
            /// removed. Any previously existing selected text must be removed.
            /// <br/>
            /// <br/>
            /// The argument text contains the pre-edit string buffer.
            /// <br/>
            /// <br/>
            /// The parameters cursor_begin and cursor_end are counted in bytes
            /// relative to the beginning of the submitted text buffer. Cursor should
            /// be hidden when both are equal to -1.
            /// <br/>
            /// <br/>
            /// They could be represented by the client as a line if both values are
            /// the same, or as a text highlight otherwise.
            /// <br/>
            /// <br/>
            /// Values set with this event are double-buffered. They must be applied
            /// and reset to initial on the next zwp_text_input_v3.done event.
            /// <br/>
            /// <br/>
            /// The initial value of text is an empty string, and cursor_begin,
            /// cursor_end and cursor_hidden are all 0.
            /// </summary>
            void OnPreeditString(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, string? @text, int @cursorBegin, int @cursorEnd);

            /// <summary>
            /// Notify when text should be inserted into the editor widget. The text to
            /// commit could be either just a single character after a key press or the
            /// result of some composing (pre-edit).
            /// <br/>
            /// <br/>
            /// Values set with this event are double-buffered. They must be applied
            /// and reset to initial on the next zwp_text_input_v3.done event.
            /// <br/>
            /// <br/>
            /// The initial value of text is an empty string.
            /// </summary>
            void OnCommitString(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, string? @text);

            /// <summary>
            /// Notify when the text around the current cursor position should be
            /// deleted.
            /// <br/>
            /// <br/>
            /// Before_length and after_length are the number of bytes before and after
            /// the current cursor index (excluding the selection) to delete.
            /// <br/>
            /// <br/>
            /// If a preedit text is present, in effect before_length is counted from
            /// the beginning of it, and after_length from its end (see done event
            /// sequence).
            /// <br/>
            /// <br/>
            /// Values set with this event are double-buffered. They must be applied
            /// and reset to initial on the next zwp_text_input_v3.done event.
            /// <br/>
            /// <br/>
            /// The initial values of both before_length and after_length are 0.
            /// </summary>
            void OnDeleteSurroundingText(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, uint @beforeLength, uint @afterLength);

            /// <summary>
            /// Instruct the application to apply changes to state requested by the
            /// preedit_string, commit_string and delete_surrounding_text events. The
            /// state relating to these events is double-buffered, and each one
            /// modifies the pending state. This event replaces the current state with
            /// the pending state.
            /// <br/>
            /// <br/>
            /// The application must proceed by evaluating the changes in the following
            /// order:
            /// <br/>
            /// <br/>
            /// 1. Replace existing preedit string with the cursor.
            /// 2. Delete requested surrounding text.
            /// 3. Insert commit string with the cursor at its end.
            /// 4. Calculate surrounding text to send.
            /// 5. Insert new preedit text in cursor position.
            /// 6. Place cursor inside preedit text.
            /// <br/>
            /// <br/>
            /// The serial number reflects the last state of the zwp_text_input_v3
            /// object known to the compositor. The value of the serial argument must
            /// be equal to the number of commit requests already issued on that object.
            /// <br/>
            /// <br/>
            /// When the client receives a done event with a serial different than the
            /// number of past commit requests, it must proceed with evaluating and
            /// applying the changes as normal, except it should not change the current
            /// state of the zwp_text_input_v3 object. All pending state requests
            /// (set_surrounding_text, set_content_type and set_cursor_rectangle) on
            /// the zwp_text_input_v3 object should be sent and committed after
            /// receiving a zwp_text_input_v3.done event with a matching serial.
            /// </summary>
            void OnDone(NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 eventSender, uint @serial);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnEnter(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnLeave(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnPreeditString(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr), arguments[1].Int32, arguments[2].Int32);
                    break;
                case 3:
                    Events?.OnCommitString(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 4:
                    Events?.OnDeleteSurroundingText(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 5:
                    Events?.OnDone(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Reason for the change of surrounding text or cursor posision.
        /// </summary>
        public enum ChangeCauseEnum
        {
            /// <summary></summary>
            InputMethod = 0,
            /// <summary></summary>
            Other = 1
        }

        /// <summary>
        /// Content hint is a bitmask to allow to modify the behavior of the text
        /// input.
        /// </summary>
        [Flags]
        public enum ContentHintEnum
        {
            /// <summary></summary>
            None = 0x0,
            /// <summary></summary>
            Completion = 0x1,
            /// <summary></summary>
            Spellcheck = 0x2,
            /// <summary></summary>
            AutoCapitalization = 0x4,
            /// <summary></summary>
            Lowercase = 0x8,
            /// <summary></summary>
            Uppercase = 0x10,
            /// <summary></summary>
            Titlecase = 0x20,
            /// <summary></summary>
            HiddenText = 0x40,
            /// <summary></summary>
            SensitiveData = 0x80,
            /// <summary></summary>
            Latin = 0x100,
            /// <summary></summary>
            Multiline = 0x200
        }

        /// <summary>
        /// The content purpose allows to specify the primary purpose of a text
        /// input.
        /// <br/>
        /// <br/>
        /// This allows an input method to show special purpose input panels with
        /// extra characters or to disallow some characters.
        /// </summary>
        public enum ContentPurposeEnum
        {
            /// <summary></summary>
            Normal = 0,
            /// <summary></summary>
            Alpha = 1,
            /// <summary></summary>
            Digits = 2,
            /// <summary></summary>
            Number = 3,
            /// <summary></summary>
            Phone = 4,
            /// <summary></summary>
            Url = 5,
            /// <summary></summary>
            Email = 6,
            /// <summary></summary>
            Name = 7,
            /// <summary></summary>
            Password = 8,
            /// <summary></summary>
            Pin = 9,
            /// <summary></summary>
            Date = 10,
            /// <summary></summary>
            Time = 11,
            /// <summary></summary>
            Datetime = 12,
            /// <summary></summary>
            Terminal = 13
        }

        private class ProxyFactory : IBindFactory<ZwpTextInputV3>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3.WlInterface);
            }

            public ZwpTextInputV3 Create(IntPtr handle, int version)
            {
                return new ZwpTextInputV3(handle, version);
            }
        }

        public static IBindFactory<ZwpTextInputV3> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_text_input_v3";
        public const int InterfaceVersion = 1;

        public ZwpTextInputV3(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A factory for text-input objects. This object is a global singleton.
    /// </summary>
    public sealed unsafe partial class ZwpTextInputManagerV3 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTextInputManagerV3()
        {
            NWayland.Protocols.TextInputUnstableV3.ZwpTextInputManagerV3.WlInterface = new WlInterface("zwp_text_input_manager_v3", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_text_input", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputManagerV3.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Creates a new text-input object for a given seat.
        /// </summary>
        public NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3 GetTextInput(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.TextInputUnstableV3.ZwpTextInputV3(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpTextInputManagerV3>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV3.ZwpTextInputManagerV3.WlInterface);
            }

            public ZwpTextInputManagerV3 Create(IntPtr handle, int version)
            {
                return new ZwpTextInputManagerV3(handle, version);
            }
        }

        public static IBindFactory<ZwpTextInputManagerV3> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_text_input_manager_v3";
        public const int InterfaceVersion = 1;

        public ZwpTextInputManagerV3(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}