using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.XdgOutputUnstableV1
{
    /// <summary>
    /// A global factory interface for xdg_output objects.
    /// </summary>
    public sealed unsafe partial class ZxdgOutputManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZxdgOutputManagerV1()
        {
            NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputManagerV1.WlInterface = new WlInterface("zxdg_output_manager_v1", 3, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_xdg_output", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// This creates a new xdg_output object for the given wl_output.
        /// </summary>
        public NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 GetXdgOutput(NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @output
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZxdgOutputManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputManagerV1.WlInterface);
            }

            public ZxdgOutputManagerV1 Create(IntPtr handle, int version)
            {
                return new ZxdgOutputManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZxdgOutputManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zxdg_output_manager_v1";
        public const int InterfaceVersion = 3;

        public ZxdgOutputManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An xdg_output describes part of the compositor geometry.
    /// <br/>
    /// <br/>
    /// This typically corresponds to a monitor that displays part of the
    /// compositor space.
    /// <br/>
    /// <br/>
    /// For objects version 3 onwards, after all xdg_output properties have been
    /// sent (when the object is created and when properties are updated), a
    /// wl_output.done event is sent. This allows changes to the output
    /// properties to be seen as atomic, even if they happen via multiple events.
    /// </summary>
    public sealed unsafe partial class ZxdgOutputV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZxdgOutputV1()
        {
            NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1.WlInterface = new WlInterface("zxdg_output_v1", 3, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("logical_position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("logical_size", "ii", new WlInterface*[] { null, null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("name", "2s", new WlInterface*[] { null }),
                new WlMessage("description", "2s", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// The position event describes the location of the wl_output within
            /// the global compositor space.
            /// <br/>
            /// <br/>
            /// The logical_position event is sent after creating an xdg_output
            /// (see xdg_output_manager.get_xdg_output) and whenever the location
            /// of the output changes within the global compositor space.
            /// </summary>
            void OnLogicalPosition(NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 eventSender, int @x, int @y);

            /// <summary>
            /// The logical_size event describes the size of the output in the
            /// global compositor space.
            /// <br/>
            /// <br/>
            /// For example, a surface without any buffer scale, transformation
            /// nor rotation set, with the size matching the logical_size will
            /// have the same size as the corresponding output when displayed.
            /// <br/>
            /// <br/>
            /// Most regular Wayland clients should not pay attention to the
            /// logical size and would rather rely on xdg_shell interfaces.
            /// <br/>
            /// <br/>
            /// Some clients such as Xwayland, however, need this to configure
            /// their surfaces in the global compositor space as the compositor
            /// may apply a different scale from what is advertised by the output
            /// scaling property (to achieve fractional scaling, for example).
            /// <br/>
            /// <br/>
            /// For example, for a wl_output mode 3840×2160 and a scale factor 2:
            /// <br/>
            /// <br/>
            /// - A compositor not scaling the surface buffers will advertise a
            /// logical size of 3840×2160,
            /// <br/>
            /// <br/>
            /// - A compositor automatically scaling the surface buffers will
            /// advertise a logical size of 1920×1080,
            /// <br/>
            /// <br/>
            /// - A compositor using a fractional scale of 1.5 will advertise a
            /// logical size of 2560×1440.
            /// <br/>
            /// <br/>
            /// For example, for a wl_output mode 1920×1080 and a 90 degree rotation,
            /// the compositor will advertise a logical size of 1080x1920.
            /// <br/>
            /// <br/>
            /// The logical_size event is sent after creating an xdg_output
            /// (see xdg_output_manager.get_xdg_output) and whenever the logical
            /// size of the output changes, either as a result of a change in the
            /// applied scale or because of a change in the corresponding output
            /// mode(see wl_output.mode) or transform (see wl_output.transform).
            /// </summary>
            void OnLogicalSize(NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 eventSender, int @width, int @height);

            /// <summary>
            /// This event is sent after all other properties of an xdg_output
            /// have been sent.
            /// <br/>
            /// <br/>
            /// This allows changes to the xdg_output properties to be seen as
            /// atomic, even if they happen via multiple events.
            /// <br/>
            /// <br/>
            /// For objects version 3 onwards, this event is deprecated. Compositors
            /// are not required to send it anymore and must send wl_output.done
            /// instead.
            /// </summary>
            void OnDone(NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 eventSender);

            /// <summary>
            /// Many compositors will assign names to their outputs, show them to the
            /// user, allow them to be configured by name, etc. The client may wish to
            /// know this name as well to offer the user similar behaviors.
            /// <br/>
            /// <br/>
            /// The naming convention is compositor defined, but limited to
            /// alphanumeric characters and dashes (-). Each name is unique among all
            /// wl_output globals, but if a wl_output global is destroyed the same name
            /// may be reused later. The names will also remain consistent across
            /// sessions with the same hardware and software configuration.
            /// <br/>
            /// <br/>
            /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
            /// not assume that the name is a reflection of an underlying DRM
            /// connector, X11 connection, etc.
            /// <br/>
            /// <br/>
            /// The name event is sent after creating an xdg_output (see
            /// xdg_output_manager.get_xdg_output). This event is only sent once per
            /// xdg_output, and the name does not change over the lifetime of the
            /// wl_output global.
            /// </summary>
            void OnName(NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 eventSender, string @name);

            /// <summary>
            /// Many compositors can produce human-readable descriptions of their
            /// outputs.  The client may wish to know this description as well, to
            /// communicate the user for various purposes.
            /// <br/>
            /// <br/>
            /// The description is a UTF-8 string with no convention defined for its
            /// contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11
            /// output via :1'.
            /// <br/>
            /// <br/>
            /// The description event is sent after creating an xdg_output (see
            /// xdg_output_manager.get_xdg_output) and whenever the description
            /// changes. The description is optional, and may not be sent at all.
            /// <br/>
            /// <br/>
            /// For objects of version 2 and lower, this event is only sent once per
            /// xdg_output, and the description does not change over the lifetime of
            /// the wl_output global.
            /// </summary>
            void OnDescription(NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1 eventSender, string @description);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnLogicalPosition(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 1:
                    Events?.OnLogicalSize(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 2:
                    Events?.OnDone(this);
                    break;
                case 3:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 4:
                    Events?.OnDescription(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZxdgOutputV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgOutputUnstableV1.ZxdgOutputV1.WlInterface);
            }

            public ZxdgOutputV1 Create(IntPtr handle, int version)
            {
                return new ZxdgOutputV1(handle, version);
            }
        }

        public static IBindFactory<ZxdgOutputV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zxdg_output_v1";
        public const int InterfaceVersion = 3;

        public ZxdgOutputV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}