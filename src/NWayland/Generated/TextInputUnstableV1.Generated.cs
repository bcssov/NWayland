using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.TextInputUnstableV1
{
    /// <summary>
    /// An object used for text input. Adds support for text input and input
    /// methods to applications. A text_input object is created from a
    /// wl_text_input_manager and corresponds typically to a text entry in an
    /// application.
    /// <br/>
    /// <br/>
    /// Requests are used to activate/deactivate the text_input object and set
    /// state information like surrounding and selected text or the content type.
    /// The information about entered text is sent to the text_input object via
    /// the pre-edit and commit events. Using this interface removes the need
    /// for applications to directly process hardware key events and compose text
    /// out of them.
    /// <br/>
    /// <br/>
    /// Text is generally UTF-8 encoded, indices and lengths are in bytes.
    /// <br/>
    /// <br/>
    /// Serials are used to synchronize the state between the text input and
    /// an input method. New serials are sent by the text input in the
    /// commit_state request and are used by the input method to indicate
    /// the known text input state in events like preedit_string, commit_string,
    /// and keysym. The text input can then ignore events from the input method
    /// which are based on an outdated state (for example after a reset).
    /// <br/>
    /// <br/>
    /// Warning! The protocol described in this file is experimental and
    /// backward incompatible changes may be made. Backward compatible changes
    /// may be added together with the corresponding interface version bump.
    /// Backward incompatible changes are done by bumping the version number in
    /// the protocol and interface names and resetting the interface version.
    /// Once the protocol is to be declared stable, the 'z' prefix and the
    /// version number in the protocol and interface names are removed and the
    /// interface version number is reset.
    /// </summary>
    public sealed unsafe partial class ZwpTextInputV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTextInputV1()
        {
            NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1.WlInterface = new WlInterface("zwp_text_input_v1", 1, new WlMessage[] {
                new WlMessage("activate", "oo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("deactivate", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) }),
                new WlMessage("show_input_panel", "", new WlInterface*[] { }),
                new WlMessage("hide_input_panel", "", new WlInterface*[] { }),
                new WlMessage("reset", "", new WlInterface*[] { }),
                new WlMessage("set_surrounding_text", "suu", new WlInterface*[] { null, null, null }),
                new WlMessage("set_content_type", "uu", new WlInterface*[] { null, null }),
                new WlMessage("set_cursor_rectangle", "iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("set_preferred_language", "s", new WlInterface*[] { null }),
                new WlMessage("commit_state", "u", new WlInterface*[] { null }),
                new WlMessage("invoke_action", "uu", new WlInterface*[] { null, null })
            }, new WlMessage[] {
                new WlMessage("enter", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("leave", "", new WlInterface*[] { }),
                new WlMessage("modifiers_map", "a", new WlInterface*[] { null }),
                new WlMessage("input_panel_state", "u", new WlInterface*[] { null }),
                new WlMessage("preedit_string", "uss", new WlInterface*[] { null, null, null }),
                new WlMessage("preedit_styling", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("preedit_cursor", "i", new WlInterface*[] { null }),
                new WlMessage("commit_string", "us", new WlInterface*[] { null, null }),
                new WlMessage("cursor_position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("delete_surrounding_text", "iu", new WlInterface*[] { null, null }),
                new WlMessage("keysym", "uuuuu", new WlInterface*[] { null, null, null, null, null }),
                new WlMessage("language", "us", new WlInterface*[] { null, null }),
                new WlMessage("text_direction", "uu", new WlInterface*[] { null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1.WlInterface);
        }

        /// <summary>
        /// Requests the text_input object to be activated (typically when the
        /// text entry gets focus).
        /// <br/>
        /// <br/>
        /// The seat argument is a wl_seat which maintains the focus for this
        /// activation. The surface argument is a wl_surface assigned to the
        /// text_input object and tracked for focus lost. The enter event
        /// is emitted on successful activation.
        /// </summary>
        public void Activate(NWayland.Protocols.Wayland.WlSeat @seat, NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat,
                @surface
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Requests the text_input object to be deactivated (typically when the
        /// text entry lost focus). The seat argument is a wl_seat which was used
        /// for activation.
        /// </summary>
        public void Deactivate(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Requests input panels (virtual keyboard) to show.
        /// </summary>
        public void ShowInputPanel()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Requests input panels (virtual keyboard) to hide.
        /// </summary>
        public void HideInputPanel()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Should be called by an editor widget when the input state should be
        /// reset, for example after the text was changed outside of the normal
        /// input method flow.
        /// </summary>
        public void Reset()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Sets the plain surrounding text around the input position. Text is
        /// UTF-8 encoded. Cursor is the byte offset within the
        /// surrounding text. Anchor is the byte offset of the
        /// selection anchor within the surrounding text. If there is no selected
        /// text anchor, then it is the same as cursor.
        /// </summary>
        public void SetSurroundingText(string @text, uint @cursor, uint @anchor)
        {
            if (@text == null)
                throw new ArgumentNullException("text");
            using var __marshalled__text = new NWaylandMarshalledString(@text);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__text,
                @cursor,
                @anchor
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Sets the content purpose and content hint. While the purpose is the
        /// basic purpose of an input field, the hint flags allow to modify some
        /// of the behavior.
        /// <br/>
        /// <br/>
        /// When no content type is explicitly set, a normal content purpose with
        /// default hints (auto completion, auto correction, auto capitalization)
        /// should be assumed.
        /// </summary>
        public void SetContentType(ContentHintEnum @hint, ContentPurposeEnum @purpose)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@hint,
                (uint)@purpose
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        public void SetCursorRectangle(int @x, int @y, int @width, int @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        /// <summary>
        /// Sets a specific language. This allows for example a virtual keyboard to
        /// show a language specific layout. The "language" argument is an RFC-3066
        /// format language tag.
        /// <br/>
        /// <br/>
        /// It could be used for example in a word processor to indicate the
        /// language of the currently edited document or in an instant message
        /// application which tracks languages of contacts.
        /// </summary>
        public void SetPreferredLanguage(string @language)
        {
            if (@language == null)
                throw new ArgumentNullException("language");
            using var __marshalled__language = new NWaylandMarshalledString(@language);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__language
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        public void CommitState(uint @serial)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        public void InvokeAction(uint @button, uint @index)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @button,
                @index
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Notify the text_input object when it received focus. Typically in
            /// response to an activate request.
            /// </summary>
            void OnEnter(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notify the text_input object when it lost focus. Either in response
            /// to a deactivate request or when the assigned surface lost focus or was
            /// destroyed.
            /// </summary>
            void OnLeave(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender);

            /// <summary>
            /// Transfer an array of 0-terminated modifier names. The position in
            /// the array is the index of the modifier as used in the modifiers
            /// bitmask in the keysym event.
            /// </summary>
            void OnModifiersMap(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, ReadOnlySpan<byte> @map);

            /// <summary>
            /// Notify when the visibility state of the input panel changed.
            /// </summary>
            void OnInputPanelState(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @state);

            /// <summary>
            /// Notify when a new composing text (pre-edit) should be set around the
            /// current cursor position. Any previously set composing text should
            /// be removed.
            /// <br/>
            /// <br/>
            /// The commit text can be used to replace the preedit text on reset
            /// (for example on unfocus).
            /// <br/>
            /// <br/>
            /// The text input should also handle all preedit_style and preedit_cursor
            /// events occurring directly before preedit_string.
            /// </summary>
            void OnPreeditString(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @serial, string @text, string @commit);

            /// <summary>
            /// Sets styling information on composing text. The style is applied for
            /// length bytes from index relative to the beginning of the composing
            /// text (as byte offset). Multiple styles can
            /// be applied to a composing text by sending multiple preedit_styling
            /// events.
            /// <br/>
            /// <br/>
            /// This event is handled as part of a following preedit_string event.
            /// </summary>
            void OnPreeditStyling(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @index, uint @length, PreeditStyleEnum @style);

            /// <summary>
            /// Sets the cursor position inside the composing text (as byte
            /// offset) relative to the start of the composing text. When index is a
            /// negative number no cursor is shown.
            /// <br/>
            /// <br/>
            /// This event is handled as part of a following preedit_string event.
            /// </summary>
            void OnPreeditCursor(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, int @index);

            /// <summary>
            /// Notify when text should be inserted into the editor widget. The text to
            /// commit could be either just a single character after a key press or the
            /// result of some composing (pre-edit). It could also be an empty text
            /// when some text should be removed (see delete_surrounding_text) or when
            /// the input cursor should be moved (see cursor_position).
            /// <br/>
            /// <br/>
            /// Any previously set composing text should be removed.
            /// </summary>
            void OnCommitString(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @serial, string @text);

            /// <summary>
            /// Notify when the cursor or anchor position should be modified.
            /// <br/>
            /// <br/>
            /// This event should be handled as part of a following commit_string
            /// event.
            /// </summary>
            void OnCursorPosition(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, int @index, int @anchor);

            /// <summary>
            /// Notify when the text around the current cursor position should be
            /// deleted.
            /// <br/>
            /// <br/>
            /// Index is relative to the current cursor (in bytes).
            /// Length is the length of deleted text (in bytes).
            /// <br/>
            /// <br/>
            /// This event should be handled as part of a following commit_string
            /// event.
            /// </summary>
            void OnDeleteSurroundingText(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, int @index, uint @length);

            /// <summary>
            /// Notify when a key event was sent. Key events should not be used
            /// for normal text input operations, which should be done with
            /// commit_string, delete_surrounding_text, etc. The key event follows
            /// the wl_keyboard key event convention. Sym is an XKB keysym, state a
            /// wl_keyboard key_state. Modifiers are a mask for effective modifiers
            /// (where the modifier indices are set by the modifiers_map event)
            /// </summary>
            void OnKeysym(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @serial, uint @time, uint @sym, uint @state, uint @modifiers);

            /// <summary>
            /// Sets the language of the input text. The "language" argument is an
            /// RFC-3066 format language tag.
            /// </summary>
            void OnLanguage(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @serial, string @language);

            /// <summary>
            /// Sets the text direction of input text.
            /// <br/>
            /// <br/>
            /// It is mainly needed for showing an input cursor on the correct side of
            /// the editor when there is no input done yet and making sure neutral
            /// direction text is laid out properly.
            /// </summary>
            void OnTextDirection(NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 eventSender, uint @serial, TextDirectionEnum @direction);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnEnter(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnLeave(this);
                    break;
                case 2:
                    Events?.OnModifiersMap(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnInputPanelState(this, arguments[0].UInt32);
                    break;
                case 4:
                    Events?.OnPreeditString(this, arguments[0].UInt32, Marshal.PtrToStringAnsi(arguments[1].IntPtr), Marshal.PtrToStringAnsi(arguments[2].IntPtr));
                    break;
                case 5:
                    Events?.OnPreeditStyling(this, arguments[0].UInt32, arguments[1].UInt32, (PreeditStyleEnum)arguments[2].UInt32);
                    break;
                case 6:
                    Events?.OnPreeditCursor(this, arguments[0].Int32);
                    break;
                case 7:
                    Events?.OnCommitString(this, arguments[0].UInt32, Marshal.PtrToStringAnsi(arguments[1].IntPtr));
                    break;
                case 8:
                    Events?.OnCursorPosition(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 9:
                    Events?.OnDeleteSurroundingText(this, arguments[0].Int32, arguments[1].UInt32);
                    break;
                case 10:
                    Events?.OnKeysym(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32, arguments[4].UInt32);
                    break;
                case 11:
                    Events?.OnLanguage(this, arguments[0].UInt32, Marshal.PtrToStringAnsi(arguments[1].IntPtr));
                    break;
                case 12:
                    Events?.OnTextDirection(this, arguments[0].UInt32, (TextDirectionEnum)arguments[1].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Content hint is a bitmask to allow to modify the behavior of the text
        /// input.
        /// </summary>
        [Flags]
        public enum ContentHintEnum
        {
            /// <summary></summary>
            None = 0x0,
            /// <summary></summary>
            Default = 0x7,
            /// <summary></summary>
            Password = 0xc0,
            /// <summary></summary>
            AutoCompletion = 0x1,
            /// <summary></summary>
            AutoCorrection = 0x2,
            /// <summary></summary>
            AutoCapitalization = 0x4,
            /// <summary></summary>
            Lowercase = 0x8,
            /// <summary></summary>
            Uppercase = 0x10,
            /// <summary></summary>
            Titlecase = 0x20,
            /// <summary></summary>
            HiddenText = 0x40,
            /// <summary></summary>
            SensitiveData = 0x80,
            /// <summary></summary>
            Latin = 0x100,
            /// <summary></summary>
            Multiline = 0x200
        }

        /// <summary>
        /// The content purpose allows to specify the primary purpose of a text
        /// input.
        /// <br/>
        /// <br/>
        /// This allows an input method to show special purpose input panels with
        /// extra characters or to disallow some characters.
        /// </summary>
        public enum ContentPurposeEnum
        {
            /// <summary></summary>
            Normal = 0,
            /// <summary></summary>
            Alpha = 1,
            /// <summary></summary>
            Digits = 2,
            /// <summary></summary>
            Number = 3,
            /// <summary></summary>
            Phone = 4,
            /// <summary></summary>
            Url = 5,
            /// <summary></summary>
            Email = 6,
            /// <summary></summary>
            Name = 7,
            /// <summary></summary>
            Password = 8,
            /// <summary></summary>
            Date = 9,
            /// <summary></summary>
            Time = 10,
            /// <summary></summary>
            Datetime = 11,
            /// <summary></summary>
            Terminal = 12
        }

        public enum PreeditStyleEnum
        {
            /// <summary></summary>
            Default = 0,
            /// <summary></summary>
            None = 1,
            Active = 2,
            Inactive = 3,
            Highlight = 4,
            Underline = 5,
            Selection = 6,
            Incorrect = 7
        }

        public enum TextDirectionEnum
        {
            /// <summary></summary>
            Auto = 0,
            /// <summary></summary>
            Ltr = 1,
            /// <summary></summary>
            Rtl = 2
        }

        private class ProxyFactory : IBindFactory<ZwpTextInputV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1.WlInterface);
            }

            public ZwpTextInputV1 Create(IntPtr handle, int version)
            {
                return new ZwpTextInputV1(handle, version);
            }
        }

        public static IBindFactory<ZwpTextInputV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_text_input_v1";
        public const int InterfaceVersion = 1;

        public ZwpTextInputV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A factory for text_input objects. This object is a global singleton.
    /// </summary>
    public sealed unsafe partial class ZwpTextInputManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTextInputManagerV1()
        {
            NWayland.Protocols.TextInputUnstableV1.ZwpTextInputManagerV1.WlInterface = new WlInterface("zwp_text_input_manager_v1", 1, new WlMessage[] {
                new WlMessage("create_text_input", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputManagerV1.WlInterface);
        }

        /// <summary>
        /// Creates a new text_input object.
        /// </summary>
        public NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1 CreateTextInput()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.TextInputUnstableV1.ZwpTextInputV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpTextInputManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TextInputUnstableV1.ZwpTextInputManagerV1.WlInterface);
            }

            public ZwpTextInputManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwpTextInputManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwpTextInputManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_text_input_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwpTextInputManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}