using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1
{
    /// <summary>
    /// This interface is a manager that allows reading and writing the currentoutput device configuration.<br/><br/>
    /// Output devices that display pixels (e.g. a physical monitor or a virtualoutput in a window) are represented as heads. Heads cannot be created nordestroyed by the client, but they can be enabled or disabled and theirproperties can be changed. Each head may have one or more available modes.<br/><br/>
    /// Whenever a head appears (e.g. a monitor is plugged in), it will beadvertised via the head event. Immediately after the output manager isbound, all current heads are advertised.<br/><br/>
    /// Whenever a head's properties change, the relevant wlr_output_head eventswill be sent. Not all head properties will be sent: only properties thathave changed need to.<br/><br/>
    /// Whenever a head disappears (e.g. a monitor is unplugged), awlr_output_head.finished event will be sent.<br/><br/>
    /// After one or more heads appear, change or disappear, the done event willbe sent. It carries a serial which can be used in a create_configurationrequest to update heads properties.<br/><br/>
    /// The information obtained from this protocol should only be used for outputconfiguration purposes. This protocol is not designed to be a genericoutput property advertisement protocol for regular clients. Instead,protocols such as xdg-output should be used.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrOutputManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrOutputManagerV1()
        {
            NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1.WlInterface = new WlInterface("zwlr_output_manager_v1", 4, new WlMessage[] {
                new WlMessage("create_configuration", "nu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1.WlInterface), null }),
                new WlMessage("stop", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("head", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface) }),
                new WlMessage("done", "u", new WlInterface*[] { null }),
                new WlMessage("finished", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1.WlInterface);
        }

        /// <summary>
        /// Create a new output configuration object. This allows to update headproperties.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1 CreateConfiguration(uint @serial)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @serial
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1(__ret, Version);
        }

        /// <summary>
        /// Indicates the client no longer wishes to receive events for outputconfiguration changes. However the compositor may emit further events,until the finished event is emitted.<br/><br/>
        /// The client must not send any more requests after this one.<br/><br/>
        /// </summary>
        public void Stop()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event introduces a new head. This happens whenever a new headappears (e.g. a monitor is plugged in) or after the output manager isbound.<br/><br/>
            /// </summary>
            void OnHead(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1 eventSender, ZwlrOutputHeadV1 @head);

            /// <summary>
            /// This event is sent after all information has been sent after binding tothe output manager object and after any subsequent changes. This appliesto child head and mode objects as well. In other words, this event issent whenever a head or mode is created or destroyed and whenever one oftheir properties has been changed. Not all state is re-sent each timethe current configuration changes: only the actual changes are sent.<br/><br/>
            /// This allows changes to the output configuration to be seen as atomic,even if they happen via multiple events.<br/><br/>
            /// A serial is sent to be used in a future create_configuration request.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1 eventSender, uint @serial);

            /// <summary>
            /// This event indicates that the compositor is done sending manager events.The compositor will destroy the object immediately after sending thisevent, so it will become invalid and the client should release anyresources associated with it.<br/><br/>
            /// </summary>
            void OnFinished(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnHead(this, new ZwlrOutputHeadV1(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnDone(this, arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnFinished(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwlrOutputManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputManagerV1.WlInterface);
            }

            public ZwlrOutputManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrOutputManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrOutputManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_output_manager_v1";
        public const int InterfaceVersion = 4;

        public ZwlrOutputManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A head is an output device. The difference between a wl_output object anda head is that heads are advertised even if they are turned off. A headobject only advertises properties and cannot be used directly to changethem.<br/><br/>
    /// A head has some read-only properties: modes, name, description andphysical_size. These cannot be changed by clients.<br/><br/>
    /// Other properties can be updated via a wlr_output_configuration object.<br/><br/>
    /// Properties sent via this interface are applied atomically via thewlr_output_manager.done event. No guarantees are made regarding the orderin which properties are sent.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrOutputHeadV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrOutputHeadV1()
        {
            NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface = new WlInterface("zwlr_output_head_v1", 4, new WlMessage[] {
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("name", "s", new WlInterface*[] { null }),
                new WlMessage("description", "s", new WlInterface*[] { null }),
                new WlMessage("physical_size", "ii", new WlInterface*[] { null, null }),
                new WlMessage("mode", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface) }),
                new WlMessage("enabled", "i", new WlInterface*[] { null }),
                new WlMessage("current_mode", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface) }),
                new WlMessage("position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("transform", "i", new WlInterface*[] { null }),
                new WlMessage("scale", "f", new WlInterface*[] { null }),
                new WlMessage("finished", "", new WlInterface*[] { }),
                new WlMessage("make", "2s", new WlInterface*[] { null }),
                new WlMessage("model", "2s", new WlInterface*[] { null }),
                new WlMessage("serial_number", "2s", new WlInterface*[] { null }),
                new WlMessage("adaptive_sync", "4u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event describes the head name.<br/><br/>
            /// The naming convention is compositor defined, but limited to alphanumericcharacters and dashes (-). Each name is unique among all wlr_output_headobjects, but if a wlr_output_head object is destroyed the same name maybe reused later. The names will also remain consistent across sessionswith the same hardware and software configuration.<br/><br/>
            /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, donot assume that the name is a reflection of an underlying DRMconnector, X11 connection, etc.<br/><br/>
            /// If the compositor implements the xdg-output protocol and this head isenabled, the xdg_output.name event must report the same name.<br/><br/>
            /// The name event is sent after a wlr_output_head object is created. Thisevent is only sent once per object, and the name does not change overthe lifetime of the wlr_output_head object.<br/><br/>
            /// </summary>
            void OnName(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, string @name);

            /// <summary>
            /// This event describes a human-readable description of the head.<br/><br/>
            /// The description is a UTF-8 string with no convention defined for itscontents. Examples might include 'Foocorp 11" Display' or 'Virtual X11output via :1'. However, do not assume that the name is a reflection ofthe make, model, serial of the underlying DRM connector or the displayname of the underlying X11 connection, etc.<br/><br/>
            /// If the compositor implements xdg-output and this head is enabled,the xdg_output.description must report the same description.<br/><br/>
            /// The description event is sent after a wlr_output_head object is created.This event is only sent once per object, and the description does notchange over the lifetime of the wlr_output_head object.<br/><br/>
            /// </summary>
            void OnDescription(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, string @description);

            /// <summary>
            /// This event describes the physical size of the head. This event is onlysent if the head has a physical size (e.g. is not a projector or avirtual device).<br/><br/>
            /// </summary>
            void OnPhysicalSize(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, int @width, int @height);

            /// <summary>
            /// This event introduces a mode for this head. It is sent once persupported mode.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, ZwlrOutputModeV1 @mode);

            /// <summary>
            /// This event describes whether the head is enabled. A disabled head is notmapped to a region of the global compositor space.<br/><br/>
            /// When a head is disabled, some properties (current_mode, position,transform and scale) are irrelevant.<br/><br/>
            /// </summary>
            void OnEnabled(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, int @enabled);

            /// <summary>
            /// This event describes the mode currently in use for this head. It is onlysent if the output is enabled.<br/><br/>
            /// </summary>
            void OnCurrentMode(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 @mode);

            /// <summary>
            /// This events describes the position of the head in the global compositorspace. It is only sent if the output is enabled.<br/><br/>
            /// </summary>
            void OnPosition(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, int @x, int @y);

            /// <summary>
            /// This event describes the transformation currently applied to the head.It is only sent if the output is enabled.<br/><br/>
            /// </summary>
            void OnTransform(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, NWayland.Protocols.Wayland.WlOutput.TransformEnum @transform);

            /// <summary>
            /// This events describes the scale of the head in the global compositorspace. It is only sent if the output is enabled.<br/><br/>
            /// </summary>
            void OnScale(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, WlFixed @scale);

            /// <summary>
            /// This event indicates that the head is no longer available. The headobject becomes inert. Clients should send a destroy request and releaseany resources associated with it.<br/><br/>
            /// </summary>
            void OnFinished(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender);

            /// <summary>
            /// This event describes the manufacturer of the head.<br/><br/>
            /// This must report the same make as the wl_output interface does in itsgeometry event.<br/><br/>
            /// Together with the model and serial_number events the purpose is toallow clients to recognize heads from previous sessions and for exampleload head-specific configurations back.<br/><br/>
            /// It is not guaranteed this event will be ever sent. A reason for thatcan be that the compositor does not have information about the make ofthe head or the definition of a make is not sensible in the currentsetup, for example in a virtual session. Clients can still try toidentify the head by available information from other events but shouldbe aware that there is an increased risk of false positives.<br/><br/>
            /// It is not recommended to display the make string in UI to users. Forthat the string provided by the description event should be preferred.<br/><br/>
            /// </summary>
            void OnMake(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, string @make);

            /// <summary>
            /// This event describes the model of the head.<br/><br/>
            /// This must report the same model as the wl_output interface does in itsgeometry event.<br/><br/>
            /// Together with the make and serial_number events the purpose is toallow clients to recognize heads from previous sessions and for exampleload head-specific configurations back.<br/><br/>
            /// It is not guaranteed this event will be ever sent. A reason for thatcan be that the compositor does not have information about the model ofthe head or the definition of a model is not sensible in the currentsetup, for example in a virtual session. Clients can still try toidentify the head by available information from other events but shouldbe aware that there is an increased risk of false positives.<br/><br/>
            /// It is not recommended to display the model string in UI to users. Forthat the string provided by the description event should be preferred.<br/><br/>
            /// </summary>
            void OnModel(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, string @model);

            /// <summary>
            /// This event describes the serial number of the head.<br/><br/>
            /// Together with the make and model events the purpose is to allow clientsto recognize heads from previous sessions and for example load head-specific configurations back.<br/><br/>
            /// It is not guaranteed this event will be ever sent. A reason for thatcan be that the compositor does not have information about the serialnumber of the head or the definition of a serial number is not sensiblein the current setup. Clients can still try to identify the head byavailable information from other events but should be aware that thereis an increased risk of false positives.<br/><br/>
            /// It is not recommended to display the serial_number string in UI tousers. For that the string provided by the description event should bepreferred.<br/><br/>
            /// </summary>
            void OnSerialNumber(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, string @serialNumber);

            /// <summary>
            /// This event describes whether adaptive sync is currently enabled forthe head or not. Adaptive sync is also known as Variable RefreshRate or VRR.<br/><br/>
            /// </summary>
            void OnAdaptiveSync(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 eventSender, AdaptiveSyncStateEnum @state);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnDescription(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnPhysicalSize(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 3:
                    Events?.OnMode(this, new ZwlrOutputModeV1(arguments[0].IntPtr, Version));
                    break;
                case 4:
                    Events?.OnEnabled(this, arguments[0].Int32);
                    break;
                case 5:
                    Events?.OnCurrentMode(this, WlProxy.FromNative<NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1>(arguments[0].IntPtr));
                    break;
                case 6:
                    Events?.OnPosition(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 7:
                    Events?.OnTransform(this, (NWayland.Protocols.Wayland.WlOutput.TransformEnum)arguments[0].Int32);
                    break;
                case 8:
                    Events?.OnScale(this, arguments[0].WlFixed);
                    break;
                case 9:
                    Events?.OnFinished(this);
                    break;
                case 10:
                    Events?.OnMake(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 11:
                    Events?.OnModel(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 12:
                    Events?.OnSerialNumber(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 13:
                    Events?.OnAdaptiveSync(this, (AdaptiveSyncStateEnum)arguments[0].UInt32);
                    break;
            }
        }

        public enum AdaptiveSyncStateEnum
        {
            /// <summary>
            /// adaptive sync is disabled<br/><br/>
            /// </summary>
            Disabled = 0,
            /// <summary>
            /// adaptive sync is enabled<br/><br/>
            /// </summary>
            Enabled = 1
        }

        private class ProxyFactory : IBindFactory<ZwlrOutputHeadV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface);
            }

            public ZwlrOutputHeadV1 Create(IntPtr handle, int version)
            {
                return new ZwlrOutputHeadV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrOutputHeadV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_output_head_v1";
        public const int InterfaceVersion = 4;

        public ZwlrOutputHeadV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object describes an output mode.<br/><br/>
    /// Some heads don't support output modes, in which case modes won't beadvertised.<br/><br/>
    /// Properties sent via this interface are applied atomically via thewlr_output_manager.done event. No guarantees are made regarding the orderin which properties are sent.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrOutputModeV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrOutputModeV1()
        {
            NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface = new WlInterface("zwlr_output_mode_v1", 3, new WlMessage[] {
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("size", "ii", new WlInterface*[] { null, null }),
                new WlMessage("refresh", "i", new WlInterface*[] { null }),
                new WlMessage("preferred", "", new WlInterface*[] { }),
                new WlMessage("finished", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event describes the mode size. The size is given in physicalhardware units of the output device. This is not necessarily the same asthe output size in the global compositor space. For instance, the outputmay be scaled or transformed.<br/><br/>
            /// </summary>
            void OnSize(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 eventSender, int @width, int @height);

            /// <summary>
            /// This event describes the mode's fixed vertical refresh rate. It is onlysent if the mode has a fixed refresh rate.<br/><br/>
            /// </summary>
            void OnRefresh(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 eventSender, int @refresh);

            /// <summary>
            /// This event advertises this mode as preferred.<br/><br/>
            /// </summary>
            void OnPreferred(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 eventSender);

            /// <summary>
            /// This event indicates that the mode is no longer available. The modeobject becomes inert. Clients should send a destroy request and releaseany resources associated with it.<br/><br/>
            /// </summary>
            void OnFinished(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSize(this, arguments[0].Int32, arguments[1].Int32);
                    break;
                case 1:
                    Events?.OnRefresh(this, arguments[0].Int32);
                    break;
                case 2:
                    Events?.OnPreferred(this);
                    break;
                case 3:
                    Events?.OnFinished(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwlrOutputModeV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface);
            }

            public ZwlrOutputModeV1 Create(IntPtr handle, int version)
            {
                return new ZwlrOutputModeV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrOutputModeV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_output_mode_v1";
        public const int InterfaceVersion = 3;

        public ZwlrOutputModeV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object is used by the client to describe a full output configuration.<br/><br/>
    /// First, the client needs to setup the output configuration. Each head canbe either enabled (and configured) or disabled. It is a protocol error tosend two enable_head or disable_head requests with the same head. It is aprotocol error to omit a head in a configuration.<br/><br/>
    /// Then, the client can apply or test the configuration. The compositor willthen reply with a succeeded, failed or cancelled event. Finally the clientshould destroy the configuration object.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrOutputConfigurationV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrOutputConfigurationV1()
        {
            NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1.WlInterface = new WlInterface("zwlr_output_configuration_v1", 4, new WlMessage[] {
                new WlMessage("enable_head", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface) }),
                new WlMessage("disable_head", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.WlInterface) }),
                new WlMessage("apply", "", new WlInterface*[] { }),
                new WlMessage("test", "", new WlInterface*[] { }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("succeeded", "", new WlInterface*[] { }),
                new WlMessage("failed", "", new WlInterface*[] { }),
                new WlMessage("cancelled", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1.WlInterface);
        }

        /// <summary>
        /// Enable a head. This request creates a head configuration object that canbe used to change the head's properties.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1 EnableHead(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 @head)
        {
            if (@head == null)
                throw new ArgumentNullException("head");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @head
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1(__ret, Version);
        }

        /// <summary>
        /// Disable a head.<br/><br/>
        /// </summary>
        public void DisableHead(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1 @head)
        {
            if (@head == null)
                throw new ArgumentNullException("head");
            WlArgument* __args = stackalloc WlArgument[] {
                @head
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Apply the new output configuration.<br/><br/>
        /// In case the configuration is successfully applied, there is no guaranteethat the new output state matches completely the requestedconfiguration. For instance, a compositor might round the scale if itdoesn't support fractional scaling.<br/><br/>
        /// After this request has been sent, the compositor must respond with ansucceeded, failed or cancelled event. Sending a request that isn't thedestructor is a protocol error.<br/><br/>
        /// </summary>
        public void Apply()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Test the new output configuration. The configuration won't be applied,but will only be validated.<br/><br/>
        /// Even if the compositor succeeds to test a configuration, applying it mayfail.<br/><br/>
        /// After this request has been sent, the compositor must respond with ansucceeded, failed or cancelled event. Sending a request that isn't thedestructor is a protocol error.<br/><br/>
        /// </summary>
        public void Test()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent after the compositor has successfully applied the changes ortested them.<br/><br/>
            /// Upon receiving this event, the client should destroy this object.<br/><br/>
            /// If the current configuration has changed, events to describe the changeswill be sent followed by a wlr_output_manager.done event.<br/><br/>
            /// </summary>
            void OnSucceeded(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1 eventSender);

            /// <summary>
            /// Sent if the compositor rejects the changes or failed to apply them. Thecompositor should revert any changes made by the apply request thattriggered this event.<br/><br/>
            /// Upon receiving this event, the client should destroy this object.<br/><br/>
            /// </summary>
            void OnFailed(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1 eventSender);

            /// <summary>
            /// Sent if the compositor cancels the configuration because the state of anoutput changed and the client has outdated information (e.g. after anoutput has been hotplugged).<br/><br/>
            /// The client can create a new configuration with a newer serial and tryagain.<br/><br/>
            /// Upon receiving this event, the client should destroy this object.<br/><br/>
            /// </summary>
            void OnCancelled(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSucceeded(this);
                    break;
                case 1:
                    Events?.OnFailed(this);
                    break;
                case 2:
                    Events?.OnCancelled(this);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// head has been configured twice<br/><br/>
            /// </summary>
            AlreadyConfiguredHead = 1,
            /// <summary>
            /// head has not been configured<br/><br/>
            /// </summary>
            UnconfiguredHead = 2,
            /// <summary>
            /// request sent after configuration has been applied or tested<br/><br/>
            /// </summary>
            AlreadyUsed = 3
        }

        private class ProxyFactory : IBindFactory<ZwlrOutputConfigurationV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationV1.WlInterface);
            }

            public ZwlrOutputConfigurationV1 Create(IntPtr handle, int version)
            {
                return new ZwlrOutputConfigurationV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrOutputConfigurationV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_output_configuration_v1";
        public const int InterfaceVersion = 4;

        public ZwlrOutputConfigurationV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object is used by the client to update a single head's configuration.<br/><br/>
    /// It is a protocol error to set the same property twice.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrOutputConfigurationHeadV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrOutputConfigurationHeadV1()
        {
            NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1.WlInterface = new WlInterface("zwlr_output_configuration_head_v1", 4, new WlMessage[] {
                new WlMessage("set_mode", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1.WlInterface) }),
                new WlMessage("set_custom_mode", "iii", new WlInterface*[] { null, null, null }),
                new WlMessage("set_position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("set_transform", "i", new WlInterface*[] { null }),
                new WlMessage("set_scale", "f", new WlInterface*[] { null }),
                new WlMessage("set_adaptive_sync", "4u", new WlInterface*[] { null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1.WlInterface);
        }

        /// <summary>
        /// This request sets the head's mode.<br/><br/>
        /// </summary>
        public void SetMode(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputModeV1 @mode)
        {
            if (@mode == null)
                throw new ArgumentNullException("mode");
            WlArgument* __args = stackalloc WlArgument[] {
                @mode
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// This request assigns a custom mode to the head. The size is given inphysical hardware units of the output device. If set to zero, therefresh rate is unspecified.<br/><br/>
        /// It is a protocol error to set both a mode and a custom mode.<br/><br/>
        /// </summary>
        public void SetCustomMode(int @width, int @height, int @refresh)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @width,
                @height,
                @refresh
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// This request sets the head's position in the global compositor space.<br/><br/>
        /// </summary>
        public void SetPosition(int @x, int @y)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// This request sets the head's transform.<br/><br/>
        /// </summary>
        public void SetTransform(NWayland.Protocols.Wayland.WlOutput.TransformEnum @transform)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (int)@transform
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// This request sets the head's scale.<br/><br/>
        /// </summary>
        public void SetScale(WlFixed @scale)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @scale
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// This request enables/disables adaptive sync. Adaptive sync is alsoknown as Variable Refresh Rate or VRR.<br/><br/>
        /// </summary>
        public void SetAdaptiveSync(NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputHeadV1.AdaptiveSyncStateEnum @state)
        {
            if (Version < 4)
                throw new InvalidOperationException("Request set_adaptive_sync is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@state
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// property has already been set<br/><br/>
            /// </summary>
            AlreadySet = 1,
            /// <summary>
            /// mode doesn't belong to head<br/><br/>
            /// </summary>
            InvalidMode = 2,
            /// <summary>
            /// mode is invalid<br/><br/>
            /// </summary>
            InvalidCustomMode = 3,
            /// <summary>
            /// transform value outside enum<br/><br/>
            /// </summary>
            InvalidTransform = 4,
            /// <summary>
            /// scale negative or zero<br/><br/>
            /// </summary>
            InvalidScale = 5,
            /// <summary>
            /// invalid enum value used in the set_adaptive_sync request<br/><br/>
            /// </summary>
            InvalidAdaptiveSyncState = 6
        }

        private class ProxyFactory : IBindFactory<ZwlrOutputConfigurationHeadV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrOutputManagementUnstableV1.ZwlrOutputConfigurationHeadV1.WlInterface);
            }

            public ZwlrOutputConfigurationHeadV1 Create(IntPtr handle, int version)
            {
                return new ZwlrOutputConfigurationHeadV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrOutputConfigurationHeadV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_output_configuration_head_v1";
        public const int InterfaceVersion = 4;

        public ZwlrOutputConfigurationHeadV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}