using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1
{
    /// <summary>
    /// The purpose of this protocol is to enable the creation of taskbarsand docks by providing them with a list of opened applications andletting them request certain actions on them, like maximizing, etc.<br/><br/>
    /// After a client binds the zwlr_foreign_toplevel_manager_v1, each openedtoplevel window will be sent via the toplevel event<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrForeignToplevelManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrForeignToplevelManagerV1()
        {
            NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelManagerV1.WlInterface = new WlInterface("zwlr_foreign_toplevel_manager_v1", 3, new WlMessage[] {
                new WlMessage("stop", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("toplevel", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1.WlInterface) }),
                new WlMessage("finished", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelManagerV1.WlInterface);
        }

        /// <summary>
        /// Indicates the client no longer wishes to receive events for new toplevels.However the compositor may emit further toplevel_created events, untilthe finished event is emitted.<br/><br/>
        /// The client must not send any more requests after this one.<br/><br/>
        /// </summary>
        public void Stop()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is emitted whenever a new toplevel window is created. Itis emitted for all toplevels, regardless of the app that has createdthem.<br/><br/>
            /// All initial details of the toplevel(title, app_id, states, etc.) willbe sent immediately after this event via the corresponding events inzwlr_foreign_toplevel_handle_v1.<br/><br/>
            /// </summary>
            void OnToplevel(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelManagerV1 eventSender, ZwlrForeignToplevelHandleV1 @toplevel);

            /// <summary>
            /// This event indicates that the compositor is done sending events to thezwlr_foreign_toplevel_manager_v1. The server will destroy the objectimmediately after sending this request, so it will become invalid andthe client should free any resources associated with it.<br/><br/>
            /// </summary>
            void OnFinished(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelManagerV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnToplevel(this, new ZwlrForeignToplevelHandleV1(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnFinished(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwlrForeignToplevelManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelManagerV1.WlInterface);
            }

            public ZwlrForeignToplevelManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrForeignToplevelManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrForeignToplevelManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_foreign_toplevel_manager_v1";
        public const int InterfaceVersion = 3;

        public ZwlrForeignToplevelManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevelwindow. Each app may have multiple opened toplevels.<br/><br/>
    /// Each toplevel has a list of outputs it is visible on, conveyed to theclient with the output_enter and output_leave events.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrForeignToplevelHandleV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrForeignToplevelHandleV1()
        {
            NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1.WlInterface = new WlInterface("zwlr_foreign_toplevel_handle_v1", 3, new WlMessage[] {
                new WlMessage("set_maximized", "", new WlInterface*[] { }),
                new WlMessage("unset_maximized", "", new WlInterface*[] { }),
                new WlMessage("set_minimized", "", new WlInterface*[] { }),
                new WlMessage("unset_minimized", "", new WlInterface*[] { }),
                new WlMessage("activate", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) }),
                new WlMessage("close", "", new WlInterface*[] { }),
                new WlMessage("set_rectangle", "oiiii", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_fullscreen", "2?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("unset_fullscreen", "2", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("title", "s", new WlInterface*[] { null }),
                new WlMessage("app_id", "s", new WlInterface*[] { null }),
                new WlMessage("output_enter", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("output_leave", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("state", "a", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("closed", "", new WlInterface*[] { }),
                new WlMessage("parent", "3?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1.WlInterface);
        }

        /// <summary>
        /// Requests that the toplevel be maximized. If the maximized state actuallychanges, this will be indicated by the state event.<br/><br/>
        /// </summary>
        public void SetMaximized()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Requests that the toplevel be unmaximized. If the maximized state actuallychanges, this will be indicated by the state event.<br/><br/>
        /// </summary>
        public void UnsetMaximized()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Requests that the toplevel be minimized. If the minimized state actuallychanges, this will be indicated by the state event.<br/><br/>
        /// </summary>
        public void SetMinimized()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Requests that the toplevel be unminimized. If the minimized state actuallychanges, this will be indicated by the state event.<br/><br/>
        /// </summary>
        public void UnsetMinimized()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Request that this toplevel be activated on the given seat.There is no guarantee the toplevel will be actually activated.<br/><br/>
        /// </summary>
        public void Activate(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Send a request to the toplevel to close itself. The compositor wouldtypically use a shell-specific method to carry out this request, forexample by sending the xdg_toplevel.close event. However, this givesno guarantees the toplevel will actually be destroyed. If and whenthis happens, the zwlr_foreign_toplevel_handle_v1.closed event willbe emitted.<br/><br/>
        /// </summary>
        public void Close()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// The rectangle of the surface specified in this request corresponds tothe place where the app using this protocol represents the given toplevel.It can be used by the compositor as a hint for some operations, e.gminimizing. The client is however not required to set this, in whichcase the compositor is free to decide some default value.<br/><br/>
        /// If the client specifies more than one rectangle, only the last one isconsidered.<br/><br/>
        /// The dimensions are given in surface-local coordinates.Setting width=height=0 removes the already-set rectangle.<br/><br/>
        /// </summary>
        public void SetRectangle(NWayland.Protocols.Wayland.WlSurface @surface, int @x, int @y, int @width, int @height)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                @surface,
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Requests that the toplevel be fullscreened on the given output. If thefullscreen state and/or the outputs the toplevel is visible on actuallychange, this will be indicated by the state and output_enter/leaveevents.<br/><br/>
        /// The output parameter is only a hint to the compositor. Also, if outputis NULL, the compositor should decide which output the toplevel will befullscreened on, if at all.<br/><br/>
        /// </summary>
        public void SetFullscreen(NWayland.Protocols.Wayland.WlOutput? @output)
        {
            if (Version < 2)
                throw new InvalidOperationException("Request set_fullscreen is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// Requests that the toplevel be unfullscreened. If the fullscreen stateactually changes, this will be indicated by the state event.<br/><br/>
        /// </summary>
        public void UnsetFullscreen()
        {
            if (Version < 2)
                throw new InvalidOperationException("Request unset_fullscreen is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is emitted whenever the title of the toplevel changes.<br/><br/>
            /// </summary>
            void OnTitle(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, string @title);

            /// <summary>
            /// This event is emitted whenever the app-id of the toplevel changes.<br/><br/>
            /// </summary>
            void OnAppId(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, string @appId);

            /// <summary>
            /// This event is emitted whenever the toplevel becomes visible onthe given output. A toplevel may be visible on multiple outputs.<br/><br/>
            /// </summary>
            void OnOutputEnter(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, NWayland.Protocols.Wayland.WlOutput @output);

            /// <summary>
            /// This event is emitted whenever the toplevel stops being visible onthe given output. It is guaranteed that an entered-output eventwith the same output has been emitted before this event.<br/><br/>
            /// </summary>
            void OnOutputLeave(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, NWayland.Protocols.Wayland.WlOutput @output);

            /// <summary>
            /// This event is emitted immediately after the zlw_foreign_toplevel_handle_v1is created and each time the toplevel state changes, either because of acompositor action or because of a request in this protocol.<br/><br/>
            /// </summary>
            void OnState(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, ReadOnlySpan<byte> @state);

            /// <summary>
            /// This event is sent after all changes in the toplevel state have beensent.<br/><br/>
            /// This allows changes to the zwlr_foreign_toplevel_handle_v1 propertiesto be seen as atomic, even if they happen via multiple events.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender);

            /// <summary>
            /// This event means the toplevel has been destroyed. It is guaranteed therewon't be any more events for this zwlr_foreign_toplevel_handle_v1. Thetoplevel itself becomes inert so any requests will be ignored except thedestroy request.<br/><br/>
            /// </summary>
            void OnClosed(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender);

            /// <summary>
            /// This event is emitted whenever the parent of the toplevel changes.<br/><br/>
            /// No event is emitted when the parent handle is destroyed by the client.<br/><br/>
            /// </summary>
            void OnParent(NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1 eventSender, NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1? @parent);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnTitle(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnAppId(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnOutputEnter(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlOutput>(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnOutputLeave(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlOutput>(arguments[0].IntPtr));
                    break;
                case 4:
                    Events?.OnState(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 5:
                    Events?.OnDone(this);
                    break;
                case 6:
                    Events?.OnClosed(this);
                    break;
                case 7:
                    Events?.OnParent(this, WlProxy.FromNative<NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1>(arguments[0].IntPtr));
                    break;
            }
        }

        /// <summary>
        /// The different states that a toplevel can have. These have the same meaningas the states with the same names defined in xdg-toplevel<br/><br/>
        /// </summary>
        public enum StateEnum
        {
            /// <summary>
            /// the toplevel is maximized<br/><br/>
            /// </summary>
            Maximized = 0,
            /// <summary>
            /// the toplevel is minimized<br/><br/>
            /// </summary>
            Minimized = 1,
            /// <summary>
            /// the toplevel is active<br/><br/>
            /// </summary>
            Activated = 2,
            /// <summary>
            /// the toplevel is fullscreen<br/><br/>
            /// </summary>
            Fullscreen = 3
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the provided rectangle is invalid<br/><br/>
            /// </summary>
            InvalidRectangle = 0
        }

        private class ProxyFactory : IBindFactory<ZwlrForeignToplevelHandleV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrForeignToplevelManagementUnstableV1.ZwlrForeignToplevelHandleV1.WlInterface);
            }

            public ZwlrForeignToplevelHandleV1 Create(IntPtr handle, int version)
            {
                return new ZwlrForeignToplevelHandleV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrForeignToplevelHandleV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_foreign_toplevel_handle_v1";
        public const int InterfaceVersion = 3;

        public ZwlrForeignToplevelHandleV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}