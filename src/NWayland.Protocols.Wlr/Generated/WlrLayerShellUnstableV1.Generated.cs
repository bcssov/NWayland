using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrLayerShellUnstableV1
{
    /// <summary>
    /// Clients can use this interface to assign the surface_layer role towl_surfaces. Such surfaces are assigned to a "layer" of the output andrendered with a defined z-depth respective to each other. They may also beanchored to the edges and corners of a screen and specify input handlingsemantics. This interface should be suitable for the implementation ofmany desktop shell components, and a broad number of other applicationsthat interact with the desktop.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrLayerShellV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrLayerShellV1()
        {
            NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerShellV1.WlInterface = new WlInterface("zwlr_layer_shell_v1", 4, new WlMessage[] {
                new WlMessage("get_layer_surface", "no?ous", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface), null, null }),
                new WlMessage("destroy", "3", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerShellV1.WlInterface);
        }

        /// <summary>
        /// Create a layer surface for an existing surface. This assigns the role oflayer_surface, or raises a protocol error if another role is alreadyassigned.<br/><br/>
        /// Creating a layer surface from a wl_surface which has a buffer attachedor committed is a client error, and any attempts by a client to attachor manipulate a buffer prior to the first layer_surface.configure callmust also be treated as errors.<br/><br/>
        /// After creating a layer_surface object and setting it up, the clientmust perform an initial commit without any buffer attached.The compositor will reply with a layer_surface.configure event.The client must acknowledge it and is then allowed to attach a bufferto map the surface.<br/><br/>
        /// You may pass NULL for output to allow the compositor to decide whichoutput to use. Generally this will be the one that the user mostrecently interacted with.<br/><br/>
        /// Clients can specify a namespace that defines the purpose of the layersurface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1 GetLayerSurface(NWayland.Protocols.Wayland.WlSurface @surface, NWayland.Protocols.Wayland.WlOutput? @output, LayerEnum @layer, string @namespace)
        {
            if (@namespace == null)
                throw new ArgumentNullException("namespace");
            if (@surface == null)
                throw new ArgumentNullException("surface");
            using var __marshalled__namespace = new NWaylandMarshalledString(@namespace);
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface,
                @output,
                (uint)@layer,
                __marshalled__namespace
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0,
            /// <summary>
            /// layer value is invalid<br/><br/>
            /// </summary>
            InvalidLayer = 1,
            /// <summary>
            /// wl_surface has a buffer attached or committed<br/><br/>
            /// </summary>
            AlreadyConstructed = 2
        }

        /// <summary>
        /// These values indicate which layers a surface can be rendered in. Theyare ordered by z depth, bottom-most first. Traditional shell surfaceswill typically be rendered between the bottom and top layers.Fullscreen shell surfaces are typically rendered at the top layer.Multiple surfaces can share a single layer, and ordering within asingle layer is undefined.<br/><br/>
        /// </summary>
        public enum LayerEnum
        {
            Background = 0,
            Bottom = 1,
            Top = 2,
            Overlay = 3
        }

        private class ProxyFactory : IBindFactory<ZwlrLayerShellV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerShellV1.WlInterface);
            }

            public ZwlrLayerShellV1 Create(IntPtr handle, int version)
            {
                return new ZwlrLayerShellV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrLayerShellV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_layer_shell_v1";
        public const int InterfaceVersion = 4;

        public ZwlrLayerShellV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An interface that may be implemented by a wl_surface, for surfaces thatare designed to be rendered as a layer of a stacked desktop-likeenvironment.<br/><br/>
    /// Layer surface state (layer, size, anchor, exclusive zone,margin, interactivity) is double-buffered, and will be applied at thetime wl_surface.commit of the corresponding wl_surface is called.<br/><br/>
    /// Attaching a null buffer to a layer surface unmaps it.<br/><br/>
    /// Unmapping a layer_surface means that the surface cannot be shown by thecompositor until it is explicitly mapped again. The layer_surfacereturns to the state it had right after layer_shell.get_layer_surface.The client can re-map the surface by performing a commit without anybuffer attached, waiting for a configure event and handling it as usual.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrLayerSurfaceV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrLayerSurfaceV1()
        {
            NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1.WlInterface = new WlInterface("zwlr_layer_surface_v1", 4, new WlMessage[] {
                new WlMessage("set_size", "uu", new WlInterface*[] { null, null }),
                new WlMessage("set_anchor", "u", new WlInterface*[] { null }),
                new WlMessage("set_exclusive_zone", "i", new WlInterface*[] { null }),
                new WlMessage("set_margin", "iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("set_keyboard_interactivity", "u", new WlInterface*[] { null }),
                new WlMessage("get_popup", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XdgShell.XdgPopup.WlInterface) }),
                new WlMessage("ack_configure", "u", new WlInterface*[] { null }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_layer", "2u", new WlInterface*[] { null })
            }, new WlMessage[] {
                new WlMessage("configure", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("closed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1.WlInterface);
        }

        /// <summary>
        /// Sets the size of the surface in surface-local coordinates. Thecompositor will display the surface centered with respect to itsanchors.<br/><br/>
        /// If you pass 0 for either value, the compositor will assign it andinform you of the assignment in the configure event. You must set youranchor to opposite edges in the dimensions you omit; not doing so is aprotocol error. Both values are 0 by default.<br/><br/>
        /// Size is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetSize(uint @width, uint @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Requests that the compositor anchor the surface to the specified edgesand corners. If two orthogonal edges are specified (e.g. 'top' and'left'), then the anchor point will be the intersection of the edges(e.g. the top left corner of the output); otherwise the anchor pointwill be centered on that edge, or in the center if none is specified.<br/><br/>
        /// Anchor is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetAnchor(AnchorEnum @anchor)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@anchor
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Requests that the compositor avoids occluding an area with othersurfaces. The compositor's use of this information isimplementation-dependent - do not assume that this region will notactually be occluded.<br/><br/>
        /// A positive value is only meaningful if the surface is anchored to oneedge or an edge and both perpendicular edges. If the surface is notanchored, anchored to only two perpendicular edges (a corner), anchoredto only two parallel edges or anchored to all edges, a positive valuewill be treated the same as zero.<br/><br/>
        /// A positive zone is the distance from the edge in surface-localcoordinates to consider exclusive.<br/><br/>
        /// Surfaces that do not wish to have an exclusive zone may instead specifyhow they should interact with surfaces that do. If set to zero, thesurface indicates that it would like to be moved to avoid occludingsurfaces with a positive exclusive zone. If set to -1, the surfaceindicates that it would not like to be moved to accommodate for othersurfaces, and the compositor should extend it all the way to the edgesit is anchored to.<br/><br/>
        /// For example, a panel might set its exclusive zone to 10, so thatmaximized shell surfaces are not shown on top of it. A notificationmight set its exclusive zone to 0, so that it is moved to avoidoccluding the panel, but shell surfaces are shown underneath it. Awallpaper or lock screen might set their exclusive zone to -1, so thatthey stretch below or over the panel.<br/><br/>
        /// The default value is 0.<br/><br/>
        /// Exclusive zone is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetExclusiveZone(int @zone)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @zone
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Requests that the surface be placed some distance away from the anchorpoint on the output, in surface-local coordinates. Setting this valuefor edges you are not anchored to has no effect.<br/><br/>
        /// The exclusive zone includes the margin.<br/><br/>
        /// Margin is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetMargin(int @top, int @right, int @bottom, int @left)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @top,
                @right,
                @bottom,
                @left
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Set how keyboard events are delivered to this surface. By default,layer shell surfaces do not receive keyboard events; this request canbe used to change this.<br/><br/>
        /// This setting is inherited by child surfaces set by the get_popuprequest.<br/><br/>
        /// Layer surfaces receive pointer, touch, and tablet events normally. Ifyou do not want to receive them, set the input region on your surfaceto an empty region.<br/><br/>
        /// Keyboard interactivity is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetKeyboardInteractivity(KeyboardInteractivityEnum @keyboardInteractivity)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@keyboardInteractivity
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// This assigns an xdg_popup's parent to this layer_surface.  This popupshould have been created via xdg_surface::get_popup with the parent setto NULL, and this request must be invoked before committing the popup'sinitial state.<br/><br/>
        /// See the documentation of xdg_popup for more details about what anxdg_popup is and how it is used.<br/><br/>
        /// </summary>
        public void GetPopup(NWayland.Protocols.XdgShell.XdgPopup @popup)
        {
            if (@popup == null)
                throw new ArgumentNullException("popup");
            WlArgument* __args = stackalloc WlArgument[] {
                @popup
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// When a configure event is received, if a client commits thesurface in response to the configure event, then the clientmust make an ack_configure request sometime before the commitrequest, passing along the serial of the configure event.<br/><br/>
        /// If the client receives multiple configure events before itcan respond to one, it only has to ack the last configure event.<br/><br/>
        /// A client is not required to commit immediately after sendingan ack_configure request - it may even ack_configure several timesbefore its next surface commit.<br/><br/>
        /// A client may send multiple ack_configure requests before committing, butonly the last request sent before a commit indicates which configureevent the client really is responding to.<br/><br/>
        /// </summary>
        public void AckConfigure(uint @serial)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Change the layer that the surface is rendered on.<br/><br/>
        /// Layer is double-buffered, see wl_surface.commit.<br/><br/>
        /// </summary>
        public void SetLayer(NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerShellV1.LayerEnum @layer)
        {
            if (Version < 2)
                throw new InvalidOperationException("Request set_layer is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@layer
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// The configure event asks the client to resize its surface.<br/><br/>
            /// Clients should arrange their surface for the new states, and then sendan ack_configure request with the serial sent in this configure event atsome point before committing the new surface.<br/><br/>
            /// The client is free to dismiss all but the last configure event itreceived.<br/><br/>
            /// The width and height arguments specify the size of the window insurface-local coordinates.<br/><br/>
            /// The size is a hint, in the sense that the client is free to ignore it ifit doesn't resize, pick a smaller size (to satisfy aspect ratio orresize in steps of NxM pixels). If the client picks a smaller size andis anchored to two opposite anchors (e.g. 'top' and 'bottom'), thesurface will be centered on this axis.<br/><br/>
            /// If the width or height arguments are zero, it means the client shoulddecide its own window dimension.<br/><br/>
            /// </summary>
            void OnConfigure(NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1 eventSender, uint @serial, uint @width, uint @height);

            /// <summary>
            /// The closed event is sent by the compositor when the surface will nolonger be shown. The output may have been destroyed or the user mayhave asked for it to be removed. Further changes to the surface will beignored. The client should destroy the resource after receiving thisevent, and create a new surface if they so choose.<br/><br/>
            /// </summary>
            void OnClosed(NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnConfigure(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
                case 1:
                    Events?.OnClosed(this);
                    break;
            }
        }

        /// <summary>
        /// Types of keyboard interaction possible for layer shell surfaces. Therationale for this is twofold: (1) some applications are not interestedin keyboard events and not allowing them to be focused can improve thedesktop experience; (2) some applications will want to take exclusivekeyboard focus.<br/><br/>
        /// </summary>
        public enum KeyboardInteractivityEnum
        {
            None = 0,
            Exclusive = 1,
            OnDemand = 2
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// provided surface state is invalid<br/><br/>
            /// </summary>
            InvalidSurfaceState = 0,
            /// <summary>
            /// size is invalid<br/><br/>
            /// </summary>
            InvalidSize = 1,
            /// <summary>
            /// anchor bitfield is invalid<br/><br/>
            /// </summary>
            InvalidAnchor = 2,
            /// <summary>
            /// keyboard interactivity is invalid<br/><br/>
            /// </summary>
            InvalidKeyboardInteractivity = 3
        }

        [Flags]
        public enum AnchorEnum
        {
            /// <summary>
            /// the top edge of the anchor rectangle<br/><br/>
            /// </summary>
            Top = 1,
            /// <summary>
            /// the bottom edge of the anchor rectangle<br/><br/>
            /// </summary>
            Bottom = 2,
            /// <summary>
            /// the left edge of the anchor rectangle<br/><br/>
            /// </summary>
            Left = 4,
            /// <summary>
            /// the right edge of the anchor rectangle<br/><br/>
            /// </summary>
            Right = 8
        }

        private class ProxyFactory : IBindFactory<ZwlrLayerSurfaceV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrLayerShellUnstableV1.ZwlrLayerSurfaceV1.WlInterface);
            }

            public ZwlrLayerSurfaceV1 Create(IntPtr handle, int version)
            {
                return new ZwlrLayerSurfaceV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrLayerSurfaceV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_layer_surface_v1";
        public const int InterfaceVersion = 4;

        public ZwlrLayerSurfaceV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}