using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrGammaControlUnstableV1
{
    /// <summary>
    /// This interface is a manager that allows creating per-output gammacontrols.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrGammaControlManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrGammaControlManagerV1()
        {
            NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlManagerV1.WlInterface = new WlInterface("zwlr_gamma_control_manager_v1", 1, new WlMessage[] {
                new WlMessage("get_gamma_control", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlManagerV1.WlInterface);
        }

        /// <summary>
        /// Create a gamma control that can be used to adjust gamma tables for theprovided output.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1 GetGammaControl(NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @output
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwlrGammaControlManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlManagerV1.WlInterface);
            }

            public ZwlrGammaControlManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrGammaControlManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrGammaControlManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_gamma_control_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwlrGammaControlManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This interface allows a client to adjust gamma tables for a particularoutput.<br/><br/>
    /// The client will receive the gamma size, and will then be able to set gammatables. At any time the compositor can send a failed event indicating thatthis object is no longer valid.<br/><br/>
    /// There can only be at most one gamma control object per output, whichhas exclusive access to this particular output. When the gamma controlobject is destroyed, the gamma table is restored to its original value.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrGammaControlV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrGammaControlV1()
        {
            NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1.WlInterface = new WlInterface("zwlr_gamma_control_v1", 1, new WlMessage[] {
                new WlMessage("set_gamma", "h", new WlInterface*[] { null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("gamma_size", "u", new WlInterface*[] { null }),
                new WlMessage("failed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1.WlInterface);
        }

        /// <summary>
        /// Set the gamma table. The file descriptor can be memory-mapped to providethe raw gamma table, which contains successive gamma ramps for the red,green and blue channels. Each gamma ramp is an array of 16-byte unsignedintegers which has the same length as the gamma size.<br/><br/>
        /// The file descriptor data must have the same length as three times thegamma size.<br/><br/>
        /// </summary>
        public void SetGamma(int @fd)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @fd
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Advertise the size of each gamma ramp.<br/><br/>
            /// This event is sent immediately when the gamma control object is created.<br/><br/>
            /// </summary>
            void OnGammaSize(NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1 eventSender, uint @size);

            /// <summary>
            /// This event indicates that the gamma control is no longer valid. Thiscan happen for a number of reasons, including:- The output doesn't support gamma tables- Setting the gamma tables failed- Another client already has exclusive gamma control for this output- The compositor has transferred gamma control to another client<br/><br/>
            /// Upon receiving this event, the client should destroy this object.<br/><br/>
            /// </summary>
            void OnFailed(NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGammaSize(this, arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnFailed(this);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// invalid gamma tables<br/><br/>
            /// </summary>
            InvalidGamma = 1
        }

        private class ProxyFactory : IBindFactory<ZwlrGammaControlV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrGammaControlUnstableV1.ZwlrGammaControlV1.WlInterface);
            }

            public ZwlrGammaControlV1 Create(IntPtr handle, int version)
            {
                return new ZwlrGammaControlV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrGammaControlV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_gamma_control_v1";
        public const int InterfaceVersion = 1;

        public ZwlrGammaControlV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}