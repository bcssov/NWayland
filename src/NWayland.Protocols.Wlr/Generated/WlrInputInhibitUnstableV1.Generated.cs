using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1
{
    /// <summary>
    /// Clients can use this interface to prevent input events from being sent toany surfaces but its own, which is useful for example in lock screensoftware. It is assumed that access to this interface will be locked downto whitelisted clients by the compositor.<br/><br/>
    /// Note! This protocol is deprecated and not intended for production use.For screen lockers, use the ext-session-lock-v1 protocol.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrInputInhibitManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrInputInhibitManagerV1()
        {
            NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitManagerV1.WlInterface = new WlInterface("zwlr_input_inhibit_manager_v1", 1, new WlMessage[] {
                new WlMessage("get_inhibitor", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitManagerV1.WlInterface);
        }

        /// <summary>
        /// Activates the input inhibitor. As long as the inhibitor is active, thecompositor will not send input events to other clients.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1 GetInhibitor()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// an input inhibitor is already in use on the compositor<br/><br/>
            /// </summary>
            AlreadyInhibited = 0
        }

        private class ProxyFactory : IBindFactory<ZwlrInputInhibitManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitManagerV1.WlInterface);
            }

            public ZwlrInputInhibitManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrInputInhibitManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrInputInhibitManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_input_inhibit_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwlrInputInhibitManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// While this resource exists, input to clients other than the owner of theinhibitor resource will not receive input events. Any client whichpreviously had focus will receive a leave event and will not be givenfocus again. The client that owns this resource will receive all inputevents normally. The compositor will also disable all of its own inputprocessing (such as keyboard shortcuts) while the inhibitor is active.<br/><br/>
    /// The compositor may continue to send input events to selected clients,such as an on-screen keyboard (via the input-method protocol).<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrInputInhibitorV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrInputInhibitorV1()
        {
            NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1.WlInterface = new WlInterface("zwlr_input_inhibitor_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwlrInputInhibitorV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrInputInhibitUnstableV1.ZwlrInputInhibitorV1.WlInterface);
            }

            public ZwlrInputInhibitorV1 Create(IntPtr handle, int version)
            {
                return new ZwlrInputInhibitorV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrInputInhibitorV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_input_inhibitor_v1";
        public const int InterfaceVersion = 1;

        public ZwlrInputInhibitorV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}