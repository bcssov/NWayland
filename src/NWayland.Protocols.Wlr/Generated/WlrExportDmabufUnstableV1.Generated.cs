using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1
{
    /// <summary>
    /// This object is a manager with which to start capturing from sources.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrExportDmabufManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrExportDmabufManagerV1()
        {
            NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufManagerV1.WlInterface = new WlInterface("zwlr_export_dmabuf_manager_v1", 1, new WlMessage[] {
                new WlMessage("capture_output", "nio", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufManagerV1.WlInterface);
        }

        /// <summary>
        /// Capture the next frame of an entire output.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1 CaptureOutput(int @overlayCursor, NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @overlayCursor,
                @output
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwlrExportDmabufManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufManagerV1.WlInterface);
            }

            public ZwlrExportDmabufManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrExportDmabufManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrExportDmabufManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_export_dmabuf_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwlrExportDmabufManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object represents a single DMA-BUF frame.<br/><br/>
    /// If the capture is successful, the compositor will first send a "frame"event, followed by one or several "object". When the frame is availablefor readout, the "ready" event is sent.<br/><br/>
    /// If the capture failed, the "cancel" event is sent. This can happen anytimebefore the "ready" event.<br/><br/>
    /// Once either a "ready" or a "cancel" event is received, the client shoulddestroy the frame. Once an "object" event is received, the client isresponsible for closing the associated file descriptor.<br/><br/>
    /// All frames are read-only and may not be written into or altered.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrExportDmabufFrameV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrExportDmabufFrameV1()
        {
            NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1.WlInterface = new WlInterface("zwlr_export_dmabuf_frame_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("frame", "uuuuuuuuuu", new WlInterface*[] { null, null, null, null, null, null, null, null, null, null }),
                new WlMessage("object", "uhuuuu", new WlInterface*[] { null, null, null, null, null, null }),
                new WlMessage("ready", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("cancel", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Main event supplying the client with information about the frame. If thecapture didn't fail, this event is always emitted first before any otherevents.<br/><br/>
            /// This event is followed by a number of "object" as specified by the"num_objects" argument.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1 eventSender, uint @width, uint @height, uint @offsetX, uint @offsetY, uint @bufferFlags, FlagsEnum @flags, uint @format, uint @modHigh, uint @modLow, uint @numObjects);

            /// <summary>
            /// Event which serves to supply the client with the file descriptorscontaining the data for each object.<br/><br/>
            /// After receiving this event, the client must always close the filedescriptor as soon as they're done with it and even if the frame fails.<br/><br/>
            /// </summary>
            void OnObject(NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1 eventSender, uint @index, int @fd, uint @size, uint @offset, uint @stride, uint @planeIndex);

            /// <summary>
            /// This event is sent as soon as the frame is presented, indicating it isavailable for reading. This event includes the time at whichpresentation happened at.<br/><br/>
            /// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,each component being an unsigned 32-bit value. Whole seconds are intv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,and the additional fractional part in tv_nsec as nanoseconds. Hence,for valid timestamps tv_nsec must be in [0, 999999999]. The seconds partmay have an arbitrary offset at start.<br/><br/>
            /// After receiving this event, the client should destroy this object.<br/><br/>
            /// </summary>
            void OnReady(NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1 eventSender, uint @tvSecHi, uint @tvSecLo, uint @tvNsec);

            /// <summary>
            /// If the capture failed or if the frame is no longer valid after the"frame" event has been emitted, this event will be used to inform theclient to scrap the frame.<br/><br/>
            /// If the failure is temporary, the client may capture again the samesource. If the failure is permanent, any further attempts to capture thesame source will fail again.<br/><br/>
            /// After receiving this event, the client should destroy this object.<br/><br/>
            /// </summary>
            void OnCancel(NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1 eventSender, CancelReasonEnum @reason);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnFrame(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32, arguments[4].UInt32, (FlagsEnum)arguments[5].UInt32, arguments[6].UInt32, arguments[7].UInt32, arguments[8].UInt32, arguments[9].UInt32);
                    break;
                case 1:
                    Events?.OnObject(this, arguments[0].UInt32, arguments[1].Int32, arguments[2].UInt32, arguments[3].UInt32, arguments[4].UInt32, arguments[5].UInt32);
                    break;
                case 2:
                    Events?.OnReady(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
                case 3:
                    Events?.OnCancel(this, (CancelReasonEnum)arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Special flags that should be respected by the client.<br/><br/>
        /// </summary>
        public enum FlagsEnum
        {
            /// <summary>
            /// clients should copy frame before processing<br/><br/>
            /// </summary>
            Transient = 0x1
        }

        /// <summary>
        /// Indicates reason for cancelling the frame.<br/><br/>
        /// </summary>
        public enum CancelReasonEnum
        {
            /// <summary>
            /// temporary error, source will produce more frames<br/><br/>
            /// </summary>
            Temporary = 0,
            /// <summary>
            /// fatal error, source will not produce frames<br/><br/>
            /// </summary>
            Permanent = 1,
            /// <summary>
            /// temporary error, source will produce more frames<br/><br/>
            /// </summary>
            Resizing = 2
        }

        private class ProxyFactory : IBindFactory<ZwlrExportDmabufFrameV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrExportDmabufUnstableV1.ZwlrExportDmabufFrameV1.WlInterface);
            }

            public ZwlrExportDmabufFrameV1 Create(IntPtr handle, int version)
            {
                return new ZwlrExportDmabufFrameV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrExportDmabufFrameV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_export_dmabuf_frame_v1";
        public const int InterfaceVersion = 1;

        public ZwlrExportDmabufFrameV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}