using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wlr.WlrScreencopyUnstableV1
{
    /// <summary>
    /// This object is a manager which offers requests to start capturing from asource.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrScreencopyManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrScreencopyManagerV1()
        {
            NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyManagerV1.WlInterface = new WlInterface("zwlr_screencopy_manager_v1", 3, new WlMessage[] {
                new WlMessage("capture_output", "nio", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("capture_output_region", "nioiiii", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface), null, null, null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyManagerV1.WlInterface);
        }

        /// <summary>
        /// Capture the next frame of an entire output.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 CaptureOutput(int @overlayCursor, NWayland.Protocols.Wayland.WlOutput @output)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @overlayCursor,
                @output
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1(__ret, Version);
        }

        /// <summary>
        /// Capture the next frame of an output's region.<br/><br/>
        /// The region is given in output logical coordinates, seexdg_output.logical_size. The region will be clipped to the output'sextents.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 CaptureOutputRegion(int @overlayCursor, NWayland.Protocols.Wayland.WlOutput @output, int @x, int @y, int @width, int @height)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @overlayCursor,
                @output,
                @x,
                @y,
                @width,
                @height
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwlrScreencopyManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyManagerV1.WlInterface);
            }

            public ZwlrScreencopyManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwlrScreencopyManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrScreencopyManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_screencopy_manager_v1";
        public const int InterfaceVersion = 3;

        public ZwlrScreencopyManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object represents a single frame.<br/><br/>
    /// When created, a series of buffer events will be sent, each representing asupported buffer type. The "buffer_done" event is sent afterwards toindicate that all supported buffer types have been enumerated. The clientwill then be able to send a "copy" request. If the capture is successful,the compositor will send a "flags" followed by a "ready" event.<br/><br/>
    /// For objects version 2 or lower, wl_shm buffers are always supported, ie.the "buffer" event is guaranteed to be sent.<br/><br/>
    /// If the capture failed, the "failed" event is sent. This can happen anytimebefore the "ready" event.<br/><br/>
    /// Once either a "ready" or a "failed" event is received, the client shoulddestroy the frame.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwlrScreencopyFrameV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwlrScreencopyFrameV1()
        {
            NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface = new WlInterface("zwlr_screencopy_frame_v1", 3, new WlMessage[] {
                new WlMessage("copy", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface) }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("copy_with_damage", "2o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("buffer", "uuuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("flags", "u", new WlInterface*[] { null }),
                new WlMessage("ready", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("failed", "", new WlInterface*[] { }),
                new WlMessage("damage", "2uuuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("linux_dmabuf", "3uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("buffer_done", "3", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface);
        }

        /// <summary>
        /// Copy the frame to the supplied buffer. The buffer must have a thecorrect size, see zwlr_screencopy_frame_v1.buffer andzwlr_screencopy_frame_v1.linux_dmabuf. The buffer needs to have asupported format.<br/><br/>
        /// If the frame is successfully copied, a "flags" and a "ready" events aresent. Otherwise, a "failed" event is sent.<br/><br/>
        /// </summary>
        public void Copy(NWayland.Protocols.Wayland.WlBuffer @buffer)
        {
            if (@buffer == null)
                throw new ArgumentNullException("buffer");
            WlArgument* __args = stackalloc WlArgument[] {
                @buffer
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Same as copy, except it waits until there is damage to copy.<br/><br/>
        /// </summary>
        public void CopyWithDamage(NWayland.Protocols.Wayland.WlBuffer @buffer)
        {
            if (@buffer == null)
                throw new ArgumentNullException("buffer");
            if (Version < 2)
                throw new InvalidOperationException("Request copy_with_damage is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                @buffer
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Provides information about wl_shm buffer parameters that need to beused for this frame. This event is sent once after the frame is createdif wl_shm buffers are supported.<br/><br/>
            /// </summary>
            void OnBuffer(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender, NWayland.Protocols.Wayland.WlShm.FormatEnum @format, uint @width, uint @height, uint @stride);

            /// <summary>
            /// Provides flags about the frame. This event is sent once before the"ready" event.<br/><br/>
            /// </summary>
            void OnFlags(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender, FlagsEnum @flags);

            /// <summary>
            /// Called as soon as the frame is copied, indicating it is availablefor reading. This event includes the time at which presentation happenedat.<br/><br/>
            /// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,each component being an unsigned 32-bit value. Whole seconds are intv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,and the additional fractional part in tv_nsec as nanoseconds. Hence,for valid timestamps tv_nsec must be in [0, 999999999]. The seconds partmay have an arbitrary offset at start.<br/><br/>
            /// After receiving this event, the client should destroy the object.<br/><br/>
            /// </summary>
            void OnReady(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender, uint @tvSecHi, uint @tvSecLo, uint @tvNsec);

            /// <summary>
            /// This event indicates that the attempted frame copy has failed.<br/><br/>
            /// After receiving this event, the client should destroy the object.<br/><br/>
            /// </summary>
            void OnFailed(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender);

            /// <summary>
            /// This event is sent right before the ready event when copy_with_damage isrequested. It may be generated multiple times for each copy_with_damagerequest.<br/><br/>
            /// The arguments describe a box around an area that has changed since thelast copy request that was derived from the current screencopy managerinstance.<br/><br/>
            /// The union of all regions received between the call to copy_with_damageand a ready event is the total damage since the prior ready event.<br/><br/>
            /// </summary>
            void OnDamage(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender, uint @x, uint @y, uint @width, uint @height);

            /// <summary>
            /// Provides information about linux-dmabuf buffer parameters that need tobe used for this frame. This event is sent once after the frame iscreated if linux-dmabuf buffers are supported.<br/><br/>
            /// </summary>
            void OnLinuxDmabuf(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender, uint @format, uint @width, uint @height);

            /// <summary>
            /// This event is sent once after all buffer events have been sent.<br/><br/>
            /// The client should proceed to create a buffer of one of the supportedtypes, and send a "copy" request.<br/><br/>
            /// </summary>
            void OnBufferDone(NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBuffer(this, (NWayland.Protocols.Wayland.WlShm.FormatEnum)arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnFlags(this, (FlagsEnum)arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnReady(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
                case 3:
                    Events?.OnFailed(this);
                    break;
                case 4:
                    Events?.OnDamage(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32);
                    break;
                case 5:
                    Events?.OnLinuxDmabuf(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
                case 6:
                    Events?.OnBufferDone(this);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the object has already been used to copy a wl_buffer<br/><br/>
            /// </summary>
            AlreadyUsed = 0,
            /// <summary>
            /// buffer attributes are invalid<br/><br/>
            /// </summary>
            InvalidBuffer = 1
        }

        [Flags]
        public enum FlagsEnum
        {
            /// <summary>
            /// contents are y-inverted<br/><br/>
            /// </summary>
            YInvert = 1
        }

        private class ProxyFactory : IBindFactory<ZwlrScreencopyFrameV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wlr.WlrScreencopyUnstableV1.ZwlrScreencopyFrameV1.WlInterface);
            }

            public ZwlrScreencopyFrameV1 Create(IntPtr handle, int version)
            {
                return new ZwlrScreencopyFrameV1(handle, version);
            }
        }

        public static IBindFactory<ZwlrScreencopyFrameV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwlr_screencopy_frame_v1";
        public const int InterfaceVersion = 3;

        public ZwlrScreencopyFrameV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}